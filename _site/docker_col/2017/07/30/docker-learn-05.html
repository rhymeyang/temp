


    



<!-- Include Data Base --> <!DOCTYPE html> <html lang="en" itemscope itemtype="http://schema.org/WebPage"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Docker系列 5 Dockerfile 常用指令 | Vicky's Blog </title> <meta name=description content=""> <meta name="robots" content="index, follow"> <meta name=viewport content="width=device-width, initial-scale=1"> <meta http-equiv="cache-control" content="public"/> <meta http-equiv="pragma" content="public"> <meta name="keywords" content="Theme, Jekyll" /> <meta name="author" content="" /> <meta property="og:locale" content="en" /> <meta property="og:site_name" content="Vicky's Blog" /> <meta property="og:type" content="WebSite" /> <meta property="og:url" content="http://www.forbackup.tk/docker_col/2017/07/30/docker-learn-05.html" /> <meta property="og:description" content="" /> <meta property="og:title" content="Docker系列 5 Dockerfile 常用指令 - Vicky's Blog" /> <link rel="canonical" href="http://www.forbackup.tk/docker_col/2017/07/30/docker-learn-05.html"> <link rel="alternate" type="application/rss+xml" title="Vicky's Blog" href="http://www.forbackup.tk/feed.xml"> <script type="application/ld+json"> {"@context": "http://schema.org", "@type": "WebSite", "name": "", "headline": "Vicky's Blog", "author": {"@type": "Person", "name": {"Vicky's Blog"}}, "description": "", "url": "http://www.forbackup.tk"} </script> <script type="text/javascript"> var GLOBAL_BASEURL = "http://www.forbackup.tk"; </script> <link rel="icon" type="image/png" sizes="16x16" href="http://www.forbackup.tk/assets/img/favicon/favicon-16x16.png"> <!-- #### VENDOR OFFLINE #### --> <!-- Bootstrap 3.3.6 - Offline --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/bootstrap/css/bootstrap.min.css"> <!-- Font Awesome 5.03 - Offline --> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/web-fonts-with-css/css/fontawesome-all.min.css"></script> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/space-mono/space-mono.min.css"> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/gloria-hallelujah/gloria-hallelujah.min.css"> <!-- Style Default --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/stylesheets/main.css"> <!-- Google Analytics --> </head> <body> <div class="main" id="top"> <div class="container wrapper"> <div class="row"> <div class="col-sm-3 sidebar"> <div class="row avatar"> <a href="http://www.forbackup.tk/"> <img class="img-responsive center-block avatar-img" src="http://www.forbackup.tk/assets/img/avatar/blog.svg" height="165" width="165" alt="Vicky's Blog"> </a> </div> <div class="row header"> <h2><a href="http://www.forbackup.tk/">Vicky </a></h2> </div> <div class="row menu"> <ul> <li> <i class="fa fa-home" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/">Home</a> </li> <hr class="breakline"> <li class="li-folder-open"> <i style="font-size: ;" class="fas fa-folder-open"></i>&nbsp;<a class="unlink">Blog</a> </li> <li class="li-fa-edit"> <i style="font-size: ;" class="fas fa-edit" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/general/" >General</a> </li> <li class="li-fa-docker"> <i style="font-size: ;" class="fab fa-docker" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/docker_col/" >Docker</a> </li> <li class="li-fa-table"> <i style="font-size: ;" class="fas fa-table" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/data_analysis/" >Data Analysis</a> </li> <li class="li-fa-tags"> <i style="font-size: ;" class="fas fa-tags" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/tags/" >Tags</a> </li> <li class="li-fa-briefcase"> <i style="font-size: ;" class="fas fa-briefcase" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/projects/" >Projects</a> </li> </ul> <div class="socials"> <div class="row"> <p></p> <p></p> </div> </div> </div> </div> <div class="col-sm-9 content-main"> <!-- Include Data Base --> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <!-- Next Version <div class="readmode"> <a id="btn-readmode" class="pull-right btn btn-default btn-readmode" href="">Read Mode</a> </div> --> <div class="row title"> <h1>Docker系列 5 Dockerfile 常用指令</h1> </div> <div class="row meta" datetime="2017-07-30"> <time class="col-sm-6 datetime"> <i class="fa fa-calendar" aria-hidden="true"></i> <span class="text tmargin ">July 30, 2017</span> </time> </div> <div class="row tag-list"> <i class="fa fa-tags" aria-hidden="true"></i> <a href="http://www.forbackup.tk/blog/tags//linux">linux</a> <a href="http://www.forbackup.tk/blog/tags//docker">docker</a> </div> <!-- <div class="row"> <ul id="markdown-toc"> <li><a href="#from" id="markdown-toc-from">FROM</a></li> <li><a href="#maintainer" id="markdown-toc-maintainer">MAINTAINER</a></li> <li><a href="#copy" id="markdown-toc-copy">COPY</a></li> <li><a href="#add" id="markdown-toc-add">ADD</a></li> <li><a href="#env" id="markdown-toc-env">ENV</a></li> <li><a href="#expose" id="markdown-toc-expose">EXPOSE</a></li> <li><a href="#volume" id="markdown-toc-volume">VOLUME</a></li> <li><a href="#workdir" id="markdown-toc-workdir">WORKDIR</a></li> <li><a href="#run" id="markdown-toc-run">RUN</a></li> <li><a href="#cmd" id="markdown-toc-cmd">CMD</a></li> <li><a href="#entrypoint" id="markdown-toc-entrypoint">ENTRYPOINT</a></li> <li><a href="#实例" id="markdown-toc-实例">实例</a></li> <li><a href="#run-vs-cmd-vs-entrypoint" id="markdown-toc-run-vs-cmd-vs-entrypoint">RUN vs CMD vs ENTRYPOINT</a> <ul> <li><a href="#shell-和-exec-格式" id="markdown-toc-shell-和-exec-格式">Shell 和 Exec 格式</a></li> <li><a href="#run-command" id="markdown-toc-run-command">RUN command</a></li> <li><a href="#cmd--command" id="markdown-toc-cmd--command">CMD command</a></li> <li><a href="#entrypoint-command" id="markdown-toc-entrypoint-command">ENTRYPOINT command</a> <ul> <li><a href="#exec-格式" id="markdown-toc-exec-格式">Exec 格式</a></li> <li><a href="#shell-格式" id="markdown-toc-shell-格式">Shell 格式</a></li> </ul> </li> </ul> </li> <li><a href="#最佳实践" id="markdown-toc-最佳实践">最佳实践</a></li> </ul> <h2 id="from">FROM</h2> <p>指定 base 镜像。</p> <h2 id="maintainer">MAINTAINER</h2> <p>设置镜像的作者，可以是任意字符串。</p> <h2 id="copy">COPY</h2> <p>将文件从 build context 复制到镜像。</p> <p>COPY 支持两种形式：</p> <ol> <li>COPY src dest</li> <li>COPY [“src”, “dest”]</li> </ol> <blockquote> <p>注意：src 只能指定 build context 中的文件或目录。</p> </blockquote> <h2 id="add">ADD</h2> <p>与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。</p> <h2 id="env">ENV</h2> <p>设置环境变量，环境变量可被后面的指令使用。例如：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> MY_VERSION 1.3</span>
<span class="k">RUN </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="nv">mypackage</span><span class="o">=</span><span class="nv">$MY_VERSION</span></code></pre></figure> <h2 id="expose">EXPOSE</h2> <p>指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。我们会在容器网络部分详细讨论。</p> <h2 id="volume">VOLUME</h2> <p>将文件或目录声明为 volume。我们会在容器存储部分详细讨论。</p> <h2 id="workdir">WORKDIR</h2> <p>为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。</p> <h2 id="run">RUN</h2> <p>在容器中运行指定的命令。</p> <h2 id="cmd">CMD</h2> <p>容器启动时运行指定的命令。 Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。</p> <h2 id="entrypoint">ENTRYPOINT</h2> <p>设置容器启动时运行的命令。 Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。</p> <h2 id="实例">实例</h2> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="c"># dockerfile example</span>
<span class="k">FROM</span><span class="s"> busybox</span>
<span class="k">MAINTAINER</span><span class="s"> yy@163.com</span>
<span class="k">WORKDIR</span><span class="s"> /testdir</span>
<span class="k">RUN </span><span class="nb">touch </span>tmpfile1
<span class="k">COPY</span><span class="s"> ["tmpfile2", "."]</span>
<span class="k">ADD</span><span class="s"> ["bunch.tar.gz", "."]</span>
<span class="k">ENV</span><span class="s"> WELCOME "You are in my container. Welcome"</span></code></pre></figure> <blockquote> <p>Dockerfile 支持以“#”开头的注释。</p> </blockquote> <p>构建镜像：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">ls
</span>Dockerfile bunch.tar.gz tmpfile2

docker build <span class="nt">-t</span> my-image   .</code></pre></figure> <p>运行容器，验证镜像内容：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> my-image   

<span class="nb">ls</span>   <span class="c"># in container</span>
bunch tmpfile1 tmpfile2</code></pre></figure> <ol> <li>进入容器，当前目录即为 WORKDIR。如果 WORKDIR 不存在，Docker 会自动为我们创建。</li> <li>WORKDIR 中保存了我们希望的文件和目录： 目录 bunch：由 <code class="highlighter-rouge">ADD</code> 指令从 build context 复制的归档文件 bunch.tar.gz，已经自动解压。 文件 tmpfile1：由 RUN 指令创建。 文件 tmpfile2：由 COPY 指令从 build context 复制。</li> <li>ENV 指令定义的环境变量已经生效。</li> </ol> <h2 id="run-vs-cmd-vs-entrypoint">RUN vs CMD vs ENTRYPOINT</h2> <p><code class="highlighter-rouge">RUN</code>、<code class="highlighter-rouge">CMD</code> 和 <code class="highlighter-rouge">ENTRYPOINT</code> 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。 简单的说：</p> <ol> <li><code class="highlighter-rouge">RUN</code> 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</li> <li><code class="highlighter-rouge">CMD</code> 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li> <li><code class="highlighter-rouge">ENTRYPOINT</code> 配置容器启动时运行的命令。</li> </ol> <h3 id="shell-和-exec-格式">Shell 和 Exec 格式</h3> <p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p> <p><strong>Shell 格式</strong></p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;instruction&gt; &lt;command&gt;
</code></pre></div></div> <p>如：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">RUN </span>apt-get <span class="nb">install </span>python3  

<span class="k">CMD</span><span class="s"> echo "Hello world"  </span>

<span class="k">ENTRYPOINT</span><span class="s"> echo "Hello world" </span></code></pre></figure> <p>当指令执行时，shell 格式底层会调用 <code class="highlighter-rouge">/bin/sh -c &lt;command&gt;</code> 。</p> <p>例如下面的 Dockerfile 片段：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> name Cloud Man  </span>

<span class="k">ENTRYPOINT</span><span class="s"> echo "Hello, $name" </span></code></pre></figure> <p>执行 <code class="highlighter-rouge">docker run &lt;image&gt;</code> 将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, Cloud Man
</code></pre></div></div> <p>注意环境变量 <code class="highlighter-rouge">name</code> 已经被值 <code class="highlighter-rouge">Cloud Man</code> 替换。</p> <p>下面来看 Exec 格式。</p> <p><strong>Exec 格式</strong></p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;instruction&gt; ["executable", "param1", "param2", ...]
</code></pre></div></div> <p>例如：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">RUN </span><span class="o">[</span><span class="s2">"apt-get"</span>, <span class="s2">"install"</span>, <span class="s2">"python3"</span><span class="o">]</span>  

<span class="k">CMD</span><span class="s"> ["/bin/echo", "Hello world"]  </span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello world"] </span></code></pre></figure> <p>当指令执行时，会直接调用 <code class="highlighter-rouge">&lt;command&gt;</code>，不会被 shell 解析。</p> <p>例如下面的 Dockerfile 片段：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> name Cloud Man  </span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello, $name"]</span></code></pre></figure> <p>运行容器将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, $name
</code></pre></div></div> <p>注意环境变量“name”没有被替换。 如果希望使用环境变量，照如下修改</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> name Cloud Man  </span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/sh", "-c", "echo Hello, $name"]</span></code></pre></figure> <p>运行容器将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, Cloud Man
</code></pre></div></div> <p>CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以</p> <h3 id="run-command">RUN command</h3> <p>RUN 指令通常用于安装应用和软件包。</p> <p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p> <p>RUN 有两种格式：</p> <ol> <li>Shell 格式：RUN</li> <li>Exec 格式：RUN [“executable”, “param1”, “param2”]</li> </ol> <p>下面是使用 RUN 安装多个包的例子：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\ </span> 
 bzr \
 cvs \
 git \
 mercurial \
 subversion</code></pre></figure> <blockquote> <p><code class="highlighter-rouge">apt-get update</code> 和 <code class="highlighter-rouge">apt-get install</code> 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p> </blockquote> <h3 id="cmd--command">CMD command</h3> <p>CMD 指令允许用户指定容器的默认执行的命令。</p> <p>此命令会在容器启动且 <code class="highlighter-rouge">docker run</code> 没有指定其他命令时运行。</p> <ol> <li>如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</li> <li>如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</li> </ol> <p>CMD 有三种格式：</p> <ol> <li>Exec 格式：CMD [“executable”,”param1”,”param2”]<br />这是 CMD 的推荐格式。</li> <li>CMD [“param1”,”param2”] 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</li> <li>Shell 格式：CMD command param1 param2</li> </ol> <p>Exec 和 Shell 格式前面已经介绍过了。 第二种格式 <code class="highlighter-rouge">CMD ["param1","param2"]</code> 要与 Exec 格式 的 <code class="highlighter-rouge">ENTRYPOINT</code> 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p> <p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">CMD</span><span class="s"> echo "Hello world"</span></code></pre></figure> <p>运行容器 docker run -it [image] 将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello world
</code></pre></div></div> <p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行</p> <h3 id="entrypoint-command">ENTRYPOINT command</h3> <p>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p> <p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p> <p>ENTRYPOINT 有两种格式：</p> <ol> <li>Exec 格式：ENTRYPOINT [“executable”, “param1”, “param2”] 这是 ENTRYPOINT 的推荐格式。</li> <li>Shell 格式：ENTRYPOINT command param1 param2</li> </ol> <p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p> <h4 id="exec-格式">Exec 格式</h4> <p>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p> <p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p> <p>比如下面的 Dockerfile 片段：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello"]  </span>

<span class="k">CMD</span><span class="s"> ["world"]</span></code></pre></figure> <p>当容器通过 <code class="highlighter-rouge">docker run -it [image]</code> 启动时，输出为：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello world
</code></pre></div></div> <p>而如果通过 <code class="highlighter-rouge">docker run -it [image] vicky</code> 启动，则输出为：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello vicky
</code></pre></div></div> <h4 id="shell-格式">Shell 格式</h4> <p>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p> <h2 id="最佳实践">最佳实践</h2> <p>使用 RUN 指令安装应用和软件包，构建镜像。</p> <p>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</p> <p>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</p> <p>到这里，我们已经具备编写 Dockerfile 的能力了。如果大家还觉得没把握，推荐一个快速掌握 Dockerfile 的方法：去 Docker Hub 上参考那些官方镜像的 Dockerfile。</p> 4683 </div> --> <div class="row content"> <ul id="markdown-toc"> <li><a href="#from" id="markdown-toc-from">FROM</a></li> <li><a href="#maintainer" id="markdown-toc-maintainer">MAINTAINER</a></li> <li><a href="#copy" id="markdown-toc-copy">COPY</a></li> <li><a href="#add" id="markdown-toc-add">ADD</a></li> <li><a href="#env" id="markdown-toc-env">ENV</a></li> <li><a href="#expose" id="markdown-toc-expose">EXPOSE</a></li> <li><a href="#volume" id="markdown-toc-volume">VOLUME</a></li> <li><a href="#workdir" id="markdown-toc-workdir">WORKDIR</a></li> <li><a href="#run" id="markdown-toc-run">RUN</a></li> <li><a href="#cmd" id="markdown-toc-cmd">CMD</a></li> <li><a href="#entrypoint" id="markdown-toc-entrypoint">ENTRYPOINT</a></li> <li><a href="#实例" id="markdown-toc-实例">实例</a></li> <li><a href="#run-vs-cmd-vs-entrypoint" id="markdown-toc-run-vs-cmd-vs-entrypoint">RUN vs CMD vs ENTRYPOINT</a> <ul> <li><a href="#shell-和-exec-格式" id="markdown-toc-shell-和-exec-格式">Shell 和 Exec 格式</a></li> <li><a href="#run-command" id="markdown-toc-run-command">RUN command</a></li> <li><a href="#cmd--command" id="markdown-toc-cmd--command">CMD command</a></li> <li><a href="#entrypoint-command" id="markdown-toc-entrypoint-command">ENTRYPOINT command</a> <ul> <li><a href="#exec-格式" id="markdown-toc-exec-格式">Exec 格式</a></li> <li><a href="#shell-格式" id="markdown-toc-shell-格式">Shell 格式</a></li> </ul> </li> </ul> </li> <li><a href="#最佳实践" id="markdown-toc-最佳实践">最佳实践</a></li> </ul> <h2 id="from">FROM</h2> <p>指定 base 镜像。</p> <h2 id="maintainer">MAINTAINER</h2> <p>设置镜像的作者，可以是任意字符串。</p> <h2 id="copy">COPY</h2> <p>将文件从 build context 复制到镜像。</p> <p>COPY 支持两种形式：</p> <ol> <li>COPY src dest</li> <li>COPY [“src”, “dest”]</li> </ol> <blockquote> <p>注意：src 只能指定 build context 中的文件或目录。</p> </blockquote> <h2 id="add">ADD</h2> <p>与 COPY 类似，从 build context 复制文件到镜像。不同的是，如果 src 是归档文件（tar, zip, tgz, xz 等），文件会被自动解压到 dest。</p> <h2 id="env">ENV</h2> <p>设置环境变量，环境变量可被后面的指令使用。例如：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> MY_VERSION 1.3</span>
<span class="k">RUN </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="nv">mypackage</span><span class="o">=</span><span class="nv">$MY_VERSION</span></code></pre></figure> <h2 id="expose">EXPOSE</h2> <p>指定容器中的进程会监听某个端口，Docker 可以将该端口暴露出来。我们会在容器网络部分详细讨论。</p> <h2 id="volume">VOLUME</h2> <p>将文件或目录声明为 volume。我们会在容器存储部分详细讨论。</p> <h2 id="workdir">WORKDIR</h2> <p>为后面的 RUN, CMD, ENTRYPOINT, ADD 或 COPY 指令设置镜像中的当前工作目录。</p> <h2 id="run">RUN</h2> <p>在容器中运行指定的命令。</p> <h2 id="cmd">CMD</h2> <p>容器启动时运行指定的命令。 Dockerfile 中可以有多个 CMD 指令，但只有最后一个生效。CMD 可以被 docker run 之后的参数替换。</p> <h2 id="entrypoint">ENTRYPOINT</h2> <p>设置容器启动时运行的命令。 Dockerfile 中可以有多个 ENTRYPOINT 指令，但只有最后一个生效。CMD 或 docker run 之后的参数会被当做参数传递给 ENTRYPOINT。</p> <h2 id="实例">实例</h2> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="c"># dockerfile example</span>
<span class="k">FROM</span><span class="s"> busybox</span>
<span class="k">MAINTAINER</span><span class="s"> yy@163.com</span>
<span class="k">WORKDIR</span><span class="s"> /testdir</span>
<span class="k">RUN </span><span class="nb">touch </span>tmpfile1
<span class="k">COPY</span><span class="s"> ["tmpfile2", "."]</span>
<span class="k">ADD</span><span class="s"> ["bunch.tar.gz", "."]</span>
<span class="k">ENV</span><span class="s"> WELCOME "You are in my container. Welcome"</span></code></pre></figure> <blockquote> <p>Dockerfile 支持以“#”开头的注释。</p> </blockquote> <p>构建镜像：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">ls
</span>Dockerfile bunch.tar.gz tmpfile2

docker build <span class="nt">-t</span> my-image   .</code></pre></figure> <p>运行容器，验证镜像内容：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> my-image   

<span class="nb">ls</span>   <span class="c"># in container</span>
bunch tmpfile1 tmpfile2</code></pre></figure> <ol> <li>进入容器，当前目录即为 WORKDIR。如果 WORKDIR 不存在，Docker 会自动为我们创建。</li> <li>WORKDIR 中保存了我们希望的文件和目录： 目录 bunch：由 <code class="highlighter-rouge">ADD</code> 指令从 build context 复制的归档文件 bunch.tar.gz，已经自动解压。 文件 tmpfile1：由 RUN 指令创建。 文件 tmpfile2：由 COPY 指令从 build context 复制。</li> <li>ENV 指令定义的环境变量已经生效。</li> </ol> <h2 id="run-vs-cmd-vs-entrypoint">RUN vs CMD vs ENTRYPOINT</h2> <p><code class="highlighter-rouge">RUN</code>、<code class="highlighter-rouge">CMD</code> 和 <code class="highlighter-rouge">ENTRYPOINT</code> 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。 简单的说：</p> <ol> <li><code class="highlighter-rouge">RUN</code> 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</li> <li><code class="highlighter-rouge">CMD</code> 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li> <li><code class="highlighter-rouge">ENTRYPOINT</code> 配置容器启动时运行的命令。</li> </ol> <h3 id="shell-和-exec-格式">Shell 和 Exec 格式</h3> <p>我们可用两种方式指定 RUN、CMD 和 ENTRYPOINT 要运行的命令：Shell 格式和 Exec 格式，二者在使用上有细微的区别。</p> <p><strong>Shell 格式</strong></p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;instruction&gt; &lt;command&gt;
</code></pre></div></div> <p>如：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">RUN </span>apt-get <span class="nb">install </span>python3  

<span class="k">CMD</span><span class="s"> echo "Hello world"  </span>

<span class="k">ENTRYPOINT</span><span class="s"> echo "Hello world" </span></code></pre></figure> <p>当指令执行时，shell 格式底层会调用 <code class="highlighter-rouge">/bin/sh -c &lt;command&gt;</code> 。</p> <p>例如下面的 Dockerfile 片段：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> name Cloud Man  </span>

<span class="k">ENTRYPOINT</span><span class="s"> echo "Hello, $name" </span></code></pre></figure> <p>执行 <code class="highlighter-rouge">docker run &lt;image&gt;</code> 将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, Cloud Man
</code></pre></div></div> <p>注意环境变量 <code class="highlighter-rouge">name</code> 已经被值 <code class="highlighter-rouge">Cloud Man</code> 替换。</p> <p>下面来看 Exec 格式。</p> <p><strong>Exec 格式</strong></p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;instruction&gt; ["executable", "param1", "param2", ...]
</code></pre></div></div> <p>例如：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">RUN </span><span class="o">[</span><span class="s2">"apt-get"</span>, <span class="s2">"install"</span>, <span class="s2">"python3"</span><span class="o">]</span>  

<span class="k">CMD</span><span class="s"> ["/bin/echo", "Hello world"]  </span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello world"] </span></code></pre></figure> <p>当指令执行时，会直接调用 <code class="highlighter-rouge">&lt;command&gt;</code>，不会被 shell 解析。</p> <p>例如下面的 Dockerfile 片段：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> name Cloud Man  </span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello, $name"]</span></code></pre></figure> <p>运行容器将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, $name
</code></pre></div></div> <p>注意环境变量“name”没有被替换。 如果希望使用环境变量，照如下修改</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENV</span><span class="s"> name Cloud Man  </span>

<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/sh", "-c", "echo Hello, $name"]</span></code></pre></figure> <p>运行容器将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, Cloud Man
</code></pre></div></div> <p>CMD 和 ENTRYPOINT 推荐使用 Exec 格式，因为指令可读性更强，更容易理解。RUN 则两种格式都可以</p> <h3 id="run-command">RUN command</h3> <p>RUN 指令通常用于安装应用和软件包。</p> <p>RUN 在当前镜像的顶部执行命令，并通过创建新的镜像层。Dockerfile 中常常包含多个 RUN 指令。</p> <p>RUN 有两种格式：</p> <ol> <li>Shell 格式：RUN</li> <li>Exec 格式：RUN [“executable”, “param1”, “param2”]</li> </ol> <p>下面是使用 RUN 安装多个包的例子：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\ </span> 
 bzr \
 cvs \
 git \
 mercurial \
 subversion</code></pre></figure> <blockquote> <p><code class="highlighter-rouge">apt-get update</code> 和 <code class="highlighter-rouge">apt-get install</code> 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建的镜像层，而这一层可能是很久以前缓存的。</p> </blockquote> <h3 id="cmd--command">CMD command</h3> <p>CMD 指令允许用户指定容器的默认执行的命令。</p> <p>此命令会在容器启动且 <code class="highlighter-rouge">docker run</code> 没有指定其他命令时运行。</p> <ol> <li>如果 docker run 指定了其他命令，CMD 指定的默认命令将被忽略。</li> <li>如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD 有效。</li> </ol> <p>CMD 有三种格式：</p> <ol> <li>Exec 格式：CMD [“executable”,”param1”,”param2”]<br />这是 CMD 的推荐格式。</li> <li>CMD [“param1”,”param2”] 为 ENTRYPOINT 提供额外的参数，此时 ENTRYPOINT 必须使用 Exec 格式。</li> <li>Shell 格式：CMD command param1 param2</li> </ol> <p>Exec 和 Shell 格式前面已经介绍过了。 第二种格式 <code class="highlighter-rouge">CMD ["param1","param2"]</code> 要与 Exec 格式 的 <code class="highlighter-rouge">ENTRYPOINT</code> 指令配合使用，其用途是为 ENTRYPOINT 设置默认的参数。我们将在后面讨论 ENTRYPOINT 时举例说明。</p> <p>下面看看 CMD 是如何工作的。Dockerfile 片段如下：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">CMD</span><span class="s"> echo "Hello world"</span></code></pre></figure> <p>运行容器 docker run -it [image] 将输出：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello world
</code></pre></div></div> <p>但当后面加上一个命令，比如 docker run -it [image] /bin/bash，CMD 会被忽略掉，命令 bash 将被执行</p> <h3 id="entrypoint-command">ENTRYPOINT command</h3> <p>ENTRYPOINT 指令可让容器以应用程序或者服务的形式运行。</p> <p>ENTRYPOINT 看上去与 CMD 很像，它们都可以指定要执行的命令及其参数。不同的地方在于 ENTRYPOINT 不会被忽略，一定会被执行，即使运行 docker run 时指定了其他命令。</p> <p>ENTRYPOINT 有两种格式：</p> <ol> <li>Exec 格式：ENTRYPOINT [“executable”, “param1”, “param2”] 这是 ENTRYPOINT 的推荐格式。</li> <li>Shell 格式：ENTRYPOINT command param1 param2</li> </ol> <p>在为 ENTRYPOINT 选择格式时必须小心，因为这两种格式的效果差别很大。</p> <h4 id="exec-格式">Exec 格式</h4> <p>ENTRYPOINT 的 Exec 格式用于设置要执行的命令及其参数，同时可通过 CMD 提供额外的参数。</p> <p>ENTRYPOINT 中的参数始终会被使用，而 CMD 的额外参数可以在容器启动时动态替换掉。</p> <p>比如下面的 Dockerfile 片段：</p> <figure class="highlight"><pre><code class="language-dockerfile" data-lang="dockerfile"><span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello"]  </span>

<span class="k">CMD</span><span class="s"> ["world"]</span></code></pre></figure> <p>当容器通过 <code class="highlighter-rouge">docker run -it [image]</code> 启动时，输出为：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello world
</code></pre></div></div> <p>而如果通过 <code class="highlighter-rouge">docker run -it [image] vicky</code> 启动，则输出为：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello vicky
</code></pre></div></div> <h4 id="shell-格式">Shell 格式</h4> <p>ENTRYPOINT 的 Shell 格式会忽略任何 CMD 或 docker run 提供的参数。</p> <h2 id="最佳实践">最佳实践</h2> <p>使用 RUN 指令安装应用和软件包，构建镜像。</p> <p>如果 Docker 镜像的用途是运行应用程序或服务，比如运行一个 MySQL，应该优先使用 Exec 格式的 ENTRYPOINT 指令。CMD 可为 ENTRYPOINT 提供额外的默认参数，同时可利用 docker run 命令行替换默认参数。</p> <p>如果想为容器设置默认的启动命令，可使用 CMD 指令。用户可在 docker run 命令行中替换此默认命令。</p> <p>到这里，我们已经具备编写 Dockerfile 的能力了。如果大家还觉得没把握，推荐一个快速掌握 Dockerfile 的方法：去 Docker Hub 上参考那些官方镜像的 Dockerfile。</p> <div class="col-sm-2 image pull-right"> <img class="avatar-img avata" style='border="0";border-radius: 50%' src="http://www.forbackup.tk/assets/img/author/blog.svg" alt="" height="32px" width="32px"> </div> </div> <ul class="pager"> <li><a href="/docker_col/2017/07/09/docker-learn-04.html">Docker系列 4 镜像</a></li> <li><a href="/docker_col/2017/07/30/docker-learn-06.html">Docker系列 6 镜像命名的最佳实践</a></li> </ul> </article> </div> </div> </div> <div class="footer"> <div class="container-fluid"> <div class="row-fluid"> <div class="col-sm-4 copyright"> <span>Vicky's Blog © 2018 • All right reserved.</span> </div> <div class="col-sm-4 message"> <span>Simplicity is fashionable.</span> </div> <div class="col-sm-4 madeby"> <span>Made with&nbsp;<a href="https://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;by&nbsp;Vicky.</span> </div> <a class="pull-right top" href="#top"><i class="fa fa-caret-up" aria-hidden="true"></i></a> </div> </div> </div> </div> <!-- Vendor - Global | Applicable to every website --> <!-- #### VENDOR OFFLINE #### --> <script src="http://www.forbackup.tk/assets/vendor-off/jquery/js/jquery.min.js"></script> <script src="http://www.forbackup.tk/assets/vendor-off/bootstrap/js/bootstrap.min.js"></script> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/svg-with-js/js/fontawesome-all.min.js"></script> <script src="http://www.forbackup.tk/assets/javascripts/jekyll-spotify-plugin.min.js"></script> <!-- Specific for each pages. --> <script type="text/javascript" src="http://www.forbackup.tk/assets/javascripts/post.js"></script> <!-- Add 'ga' function from Google Analytics to certain site links in Posts --> <!-- App | Global --> <script src="http://www.forbackup.tk/assets/javascripts/global.js"></script> </body> </html>




    



<!-- Include Data Base --> <!DOCTYPE html> <html lang="en" itemscope itemtype="http://schema.org/WebPage"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Docker系列 10 限制容器对内存的使用 | Vicky's Blog </title> <meta name=description content=""> <meta name="robots" content="index, follow"> <meta name=viewport content="width=device-width, initial-scale=1"> <meta http-equiv="cache-control" content="public"/> <meta http-equiv="pragma" content="public"> <meta name="keywords" content="Theme, Jekyll" /> <meta name="author" content="" /> <meta property="og:locale" content="en" /> <meta property="og:site_name" content="Vicky's Blog" /> <meta property="og:type" content="WebSite" /> <meta property="og:url" content="http://www.forbackup.tk/docker_col/2017/08/06/docker-learn-10.html" /> <meta property="og:description" content="" /> <meta property="og:title" content="Docker系列 10 限制容器对内存的使用 - Vicky's Blog" /> <link rel="canonical" href="http://www.forbackup.tk/docker_col/2017/08/06/docker-learn-10.html"> <link rel="alternate" type="application/rss+xml" title="Vicky's Blog" href="http://www.forbackup.tk/feed.xml"> <script type="application/ld+json"> {"@context": "http://schema.org", "@type": "WebSite", "name": "", "headline": "Vicky's Blog", "author": {"@type": "Person", "name": {"Vicky's Blog"}}, "description": "", "url": "http://www.forbackup.tk"} </script> <script type="text/javascript"> var GLOBAL_BASEURL = "http://www.forbackup.tk"; </script> <link rel="icon" type="image/png" sizes="16x16" href="http://www.forbackup.tk/assets/img/favicon/favicon-16x16.png"> <!-- #### VENDOR OFFLINE #### --> <!-- Bootstrap 3.3.6 - Offline --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/bootstrap/css/bootstrap.min.css"> <!-- Font Awesome 5.03 - Offline --> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/web-fonts-with-css/css/fontawesome-all.min.css"></script> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/space-mono/space-mono.min.css"> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/gloria-hallelujah/gloria-hallelujah.min.css"> <!-- Style Default --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/stylesheets/main.css"> <!-- Google Analytics --> </head> <body> <div class="main" id="top"> <div class="container wrapper"> <div class="row"> <div class="col-sm-3 sidebar"> <div class="row avatar"> <a href="http://www.forbackup.tk/"> <img class="img-responsive center-block avatar-img" src="http://www.forbackup.tk/assets/img/avatar/blog.svg" height="165" width="165" alt="Vicky's Blog"> </a> </div> <div class="row header"> <h2><a href="http://www.forbackup.tk/">Vicky </a></h2> </div> <div class="row menu"> <ul> <li> <i class="fa fa-home" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/">Home</a> </li> <hr class="breakline"> <li class="li-folder-open"> <i style="font-size: ;" class="fas fa-folder-open"></i>&nbsp;<a class="unlink">Blog</a> </li> <li class="li-fa-edit"> <i style="font-size: ;" class="fas fa-edit" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/general/" >General</a> </li> <li class="li-fa-docker"> <i style="font-size: ;" class="fab fa-docker" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/docker_col/" >Docker</a> </li> <li class="li-fa-table"> <i style="font-size: ;" class="fas fa-table" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/data_analysis/" >Data Analysis</a> </li> <li class="li-fa-tags"> <i style="font-size: ;" class="fas fa-tags" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/tags/" >Tags</a> </li> <li class="li-fa-briefcase"> <i style="font-size: ;" class="fas fa-briefcase" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/projects/" >Projects</a> </li> </ul> <div class="socials"> <div class="row"> <p></p> <p></p> </div> </div> </div> </div> <div class="col-sm-9 content-main"> <!-- Include Data Base --> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <!-- Next Version <div class="readmode"> <a id="btn-readmode" class="pull-right btn btn-default btn-readmode" href="">Read Mode</a> </div> --> <div class="row title"> <h1>Docker系列 10 限制容器对内存的使用</h1> </div> <div class="row meta" datetime="2017-08-06"> <time class="col-sm-6 datetime"> <i class="fa fa-calendar" aria-hidden="true"></i> <span class="text tmargin ">August 06, 2017</span> </time> </div> <div class="row tag-list"> <i class="fa fa-tags" aria-hidden="true"></i> <a href="http://www.forbackup.tk/blog/tags//linux">linux</a> <a href="http://www.forbackup.tk/blog/tags//docker">docker</a> </div> <!-- <div class="row"> <ul id="markdown-toc"> <li><a href="#内存限额" id="markdown-toc-内存限额">内存限额</a></li> <li><a href="#限制容器对cpu的使用" id="markdown-toc-限制容器对cpu的使用">限制容器对CPU的使用</a> <ul> <li><a href="#1-启动-container_acpu-share-为-1024" id="markdown-toc-1-启动-container_acpu-share-为-1024">1. 启动 container_A，cpu share 为 1024：</a></li> <li><a href="#2-启动-container_bcpu-share-为-512" id="markdown-toc-2-启动-container_bcpu-share-为-512">2. 启动 container_B，cpu share 为 512：</a></li> <li><a href="#3-在-host-中执行-top查看容器对-cpu-的使用情况" id="markdown-toc-3-在-host-中执行-top查看容器对-cpu-的使用情况">3. 在 host 中执行 top，查看容器对 CPU 的使用情况：</a></li> <li><a href="#4-现在暂停-container_a" id="markdown-toc-4-现在暂停-container_a">4. 现在暂停 container_A：</a></li> </ul> </li> <li><a href="#限制容器的-block-io" id="markdown-toc-限制容器的-block-io">限制容器的 Block IO</a> <ul> <li><a href="#block-io-权重" id="markdown-toc-block-io-权重">block IO 权重</a></li> <li><a href="#限制-bps-和-iops" id="markdown-toc-限制-bps-和-iops">限制 bps 和 iops</a></li> </ul> </li> </ul> <p>限制容器对内存的使用</p> <p>一个 docker host 上会运行若干容器，每个容器都需要 CPU、内存和 IO 资源。对于 KVM，VMware 等虚拟化技术，用户可以控制分配多少 CPU、内存资源给每个虚拟机。对于容器，Docker 也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个 host 的性能。</p> <h2 id="内存限额">内存限额</h2> <p>与操作系统类似，容器可使用的内存包括两部分：物理内存和 swap。 Docker 通过下面两组参数来控制容器内存的使用量。</p> <ol> <li><code class="highlighter-rouge">-m</code> 或 <code class="highlighter-rouge">--memory</code>：设置内存的使用限额，例如 100M, 2G。</li> <li><code class="highlighter-rouge">--memory-swap</code>：设置 内存+swap 的使用限额。</li> </ol> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-m</span> 200M <span class="nt">--memory-swap</span><span class="o">=</span>300M centos</code></pre></figure> <p>其含义是允许该容器最多使用 200M 的内存和 100M 的 swap。默认情况下，上面两组参数为 <code class="highlighter-rouge">-1</code>，即对容器内存和 swap 的使用没有限制。</p> <p>下面我们将使用 progrium/stress 镜像来学习如何为容器分配内存。该镜像可用于对容器执行压力测试。执行如下命令：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">-m</span> 200M <span class="nt">--memory-swap</span><span class="o">=</span>300M progrium/stress <span class="nt">--vm</span> 1 <span class="nt">--vm-bytes</span> 280M</code></pre></figure> <ul> <li><code class="highlighter-rouge">--vm 1</code>：启动 1 个内存工作线程。</li> <li><code class="highlighter-rouge">--vm-bytes 280M</code>：每个线程分配 280M 内存。</li> </ul> <p><a href="https://hub.docker.com/r/progrium/stress/">压力测试工具</a></p> <p>因为 280M 在可分配的范围（300M）内，所以工作线程能够正常工作，其过程是：</p> <ul> <li>分配 280M 内存。</li> <li>释放 280M 内存。</li> <li>再分配 280M 内存。</li> <li>再释放 280M 内存。</li> <li>一直循环……</li> </ul> <p>如果让工作线程分配的内存超过 300M，结果如下：</p> <p><img src="http://www.forbackup.tk/assets/img/used/docker/stress_fail.jpg" alt="stress fail @x100" /></p> <p>分配的内存超过限额，stress 线程报错，容器退出。</p> <p>如果在启动容器时只指定 -m 而不指定 –memory-swap，那么 –memory-swap 默认为 -m 的两倍，比如：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">-m</span> 200M ubuntu</code></pre></figure> <p>容器最多使用 200M 物理内存和 200M swap。</p> <h2 id="限制容器对cpu的使用">限制容器对CPU的使用</h2> <p>上节学习了如何限制容器对内存的使用，本节我们来看CPU。</p> <p>默认设置下，所有容器可以平等地使用 host CPU 资源并且没有限制。</p> <p>Docker 可以通过 <code class="highlighter-rouge">-c</code> 或 <code class="highlighter-rouge">--cpu-shares</code> 设置容器使用 CPU 的权重。如果不指定，默认值为 1024。</p> <p>与内存限额不同，通过 <code class="highlighter-rouge">-c</code> 设置的 <code class="highlighter-rouge">cpu share</code> 并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的 CPU 资源取决于它的 cpu share 占所有容器 cpu share 总和的比例。</p> <p>换句话说：<strong>通过 cpu share 可以设置容器使用 CPU 的优先级。</strong></p> <p>比如在 host 中启动了两个容器：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> <span class="s2">"container_A"</span> <span class="nt">-c</span> 1024 ubuntu

docker run <span class="nt">--name</span> <span class="s2">"container_B"</span> <span class="nt">-c</span> 512 ubuntu</code></pre></figure> <p>container_A 的 cpu share 1024，是 container_B 的两倍。当两个容器都需要 CPU 资源时，container_A 可以得到的 CPU 是 container_B 的两倍。</p> <p>需要特别注意的是，这种按权重分配 CPU 只会发生在 CPU 资源紧张的情况下。如果 container_A 处于空闲状态，这时，为了充分利用 CPU 资源，container_B 也可以分配到全部可用的 CPU。</p> <p>下面我们继续用 progrium/stress 做实验。</p> <h3 id="1-启动-container_acpu-share-为-1024">1. 启动 container_A，cpu share 为 1024：</h3> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> container_A <span class="nt">-it</span> <span class="nt">-c</span> 1024 progrium/stress <span class="nt">--cpu</span> 1</code></pre></figure> <p><code class="highlighter-rouge">--cpu</code> 用来设置工作线程的数量。因为当前 host 只有 1 颗 CPU，所以一个工作线程就能将 CPU 压满。如果 host 有多颗 CPU，则需要相应增加 <code class="highlighter-rouge">--cpu</code> 的数量。</p> <h3 id="2-启动-container_bcpu-share-为-512">2. 启动 container_B，cpu share 为 512：</h3> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> container_B <span class="nt">-it</span> <span class="nt">-c</span> 512 progrium/stress <span class="nt">--cpu</span> 1</code></pre></figure> <h3 id="3-在-host-中执行-top查看容器对-cpu-的使用情况">3. 在 host 中执行 top，查看容器对 CPU 的使用情况：</h3> <p>container_A 消耗的 CPU 是 container_B 的两倍。</p> <h3 id="4-现在暂停-container_a">4. 现在暂停 container_A：</h3> <p><code class="highlighter-rouge">top</code> 显示 container_B 在 container_A 空闲的情况下能够用满整颗 CPU：</p> <h2 id="限制容器的-block-io">限制容器的 Block IO</h2> <p>Block IO 是另一种可以限制容器使用的资源。Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽，下面分别讨论。</p> <blockquote> <p>注：目前 Block IO 限额只对 direct IO（不使用文件缓存）有效。</p> </blockquote> <h3 id="block-io-权重">block IO 权重</h3> <p>默认情况下，所有容器能平等地读写磁盘，可以通过设置 <code class="highlighter-rouge">--blkio-weight</code> 参数来改变容器 block IO 的优先级。</p> <p><code class="highlighter-rouge">--blkio-weight</code> 与 <code class="highlighter-rouge">--cpu-shares</code> 类似，设置的是相对权重值，默认为 500。在下面的例子中，container_A 读写磁盘的带宽是 container_B 的两倍。</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">--name</span> container_A <span class="nt">--blkio-weight</span> 600 ubuntu   

docker run <span class="nt">-it</span> <span class="nt">--name</span> container_B <span class="nt">--blkio-weight</span> 300 ubuntu</code></pre></figure> <h3 id="限制-bps-和-iops">限制 bps 和 iops</h3> <p><code class="highlighter-rouge">bps</code> 是 byte per second，每秒读写的数据量。 <code class="highlighter-rouge">iops</code> 是 io per second，每秒 IO 的次数。</p> <p>可通过以下参数控制容器的 bps 和 iops：</p> <ul> <li><code class="highlighter-rouge">--device-read-bps</code>，限制读某个设备的 bps。</li> <li><code class="highlighter-rouge">--device-write-bps</code>，限制写某个设备的 bps。</li> <li><code class="highlighter-rouge">--device-read-iops</code>，限制读某个设备的 iops。</li> <li><code class="highlighter-rouge">--device-write-iops</code>，限制写某个设备的 iops。</li> </ul> <p>下面这个例子限制容器写 /dev/sda 的速率为 30 MB/s</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">--device-write-bps</span> /dev/sda:30MB ubuntu</code></pre></figure> <p><img src="http://www.forbackup.tk/assets/img/used/docker/io_test.jpg" alt="block rate @x100" /></p> <p>通过 dd 测试在容器中写磁盘的速度。因为容器的文件系统是在 host /dev/sda 上的，在容器中写文件相当于对 host /dev/sda 进行写操作。另外，<code class="highlighter-rouge">oflag=direct</code> 指定用 direct IO 方式写文件，这样 <code class="highlighter-rouge">--device-write-bps</code> 才能生效。</p> <p>结果表明，bps 25.6 MB/s 没有超过 30 MB/s 的限速。</p> <p>作为对比测试，如果不限速，结果如下：</p> <p><img src="http://www.forbackup.tk/assets/img/used/docker/io_test_unlimit.jpg" alt="block rate @x100" /></p> 3153 </div> --> <div class="row content"> <ul id="markdown-toc"> <li><a href="#内存限额" id="markdown-toc-内存限额">内存限额</a></li> <li><a href="#限制容器对cpu的使用" id="markdown-toc-限制容器对cpu的使用">限制容器对CPU的使用</a> <ul> <li><a href="#1-启动-container_acpu-share-为-1024" id="markdown-toc-1-启动-container_acpu-share-为-1024">1. 启动 container_A，cpu share 为 1024：</a></li> <li><a href="#2-启动-container_bcpu-share-为-512" id="markdown-toc-2-启动-container_bcpu-share-为-512">2. 启动 container_B，cpu share 为 512：</a></li> <li><a href="#3-在-host-中执行-top查看容器对-cpu-的使用情况" id="markdown-toc-3-在-host-中执行-top查看容器对-cpu-的使用情况">3. 在 host 中执行 top，查看容器对 CPU 的使用情况：</a></li> <li><a href="#4-现在暂停-container_a" id="markdown-toc-4-现在暂停-container_a">4. 现在暂停 container_A：</a></li> </ul> </li> <li><a href="#限制容器的-block-io" id="markdown-toc-限制容器的-block-io">限制容器的 Block IO</a> <ul> <li><a href="#block-io-权重" id="markdown-toc-block-io-权重">block IO 权重</a></li> <li><a href="#限制-bps-和-iops" id="markdown-toc-限制-bps-和-iops">限制 bps 和 iops</a></li> </ul> </li> </ul> <p>限制容器对内存的使用</p> <p>一个 docker host 上会运行若干容器，每个容器都需要 CPU、内存和 IO 资源。对于 KVM，VMware 等虚拟化技术，用户可以控制分配多少 CPU、内存资源给每个虚拟机。对于容器，Docker 也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个 host 的性能。</p> <h2 id="内存限额">内存限额</h2> <p>与操作系统类似，容器可使用的内存包括两部分：物理内存和 swap。 Docker 通过下面两组参数来控制容器内存的使用量。</p> <ol> <li><code class="highlighter-rouge">-m</code> 或 <code class="highlighter-rouge">--memory</code>：设置内存的使用限额，例如 100M, 2G。</li> <li><code class="highlighter-rouge">--memory-swap</code>：设置 内存+swap 的使用限额。</li> </ol> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-m</span> 200M <span class="nt">--memory-swap</span><span class="o">=</span>300M centos</code></pre></figure> <p>其含义是允许该容器最多使用 200M 的内存和 100M 的 swap。默认情况下，上面两组参数为 <code class="highlighter-rouge">-1</code>，即对容器内存和 swap 的使用没有限制。</p> <p>下面我们将使用 progrium/stress 镜像来学习如何为容器分配内存。该镜像可用于对容器执行压力测试。执行如下命令：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">-m</span> 200M <span class="nt">--memory-swap</span><span class="o">=</span>300M progrium/stress <span class="nt">--vm</span> 1 <span class="nt">--vm-bytes</span> 280M</code></pre></figure> <ul> <li><code class="highlighter-rouge">--vm 1</code>：启动 1 个内存工作线程。</li> <li><code class="highlighter-rouge">--vm-bytes 280M</code>：每个线程分配 280M 内存。</li> </ul> <p><a href="https://hub.docker.com/r/progrium/stress/">压力测试工具</a></p> <p>因为 280M 在可分配的范围（300M）内，所以工作线程能够正常工作，其过程是：</p> <ul> <li>分配 280M 内存。</li> <li>释放 280M 内存。</li> <li>再分配 280M 内存。</li> <li>再释放 280M 内存。</li> <li>一直循环……</li> </ul> <p>如果让工作线程分配的内存超过 300M，结果如下：</p> <p><img src="http://www.forbackup.tk/assets/img/used/docker/stress_fail.jpg" alt="stress fail @x100" /></p> <p>分配的内存超过限额，stress 线程报错，容器退出。</p> <p>如果在启动容器时只指定 -m 而不指定 –memory-swap，那么 –memory-swap 默认为 -m 的两倍，比如：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">-m</span> 200M ubuntu</code></pre></figure> <p>容器最多使用 200M 物理内存和 200M swap。</p> <h2 id="限制容器对cpu的使用">限制容器对CPU的使用</h2> <p>上节学习了如何限制容器对内存的使用，本节我们来看CPU。</p> <p>默认设置下，所有容器可以平等地使用 host CPU 资源并且没有限制。</p> <p>Docker 可以通过 <code class="highlighter-rouge">-c</code> 或 <code class="highlighter-rouge">--cpu-shares</code> 设置容器使用 CPU 的权重。如果不指定，默认值为 1024。</p> <p>与内存限额不同，通过 <code class="highlighter-rouge">-c</code> 设置的 <code class="highlighter-rouge">cpu share</code> 并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的 CPU 资源取决于它的 cpu share 占所有容器 cpu share 总和的比例。</p> <p>换句话说：<strong>通过 cpu share 可以设置容器使用 CPU 的优先级。</strong></p> <p>比如在 host 中启动了两个容器：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> <span class="s2">"container_A"</span> <span class="nt">-c</span> 1024 ubuntu

docker run <span class="nt">--name</span> <span class="s2">"container_B"</span> <span class="nt">-c</span> 512 ubuntu</code></pre></figure> <p>container_A 的 cpu share 1024，是 container_B 的两倍。当两个容器都需要 CPU 资源时，container_A 可以得到的 CPU 是 container_B 的两倍。</p> <p>需要特别注意的是，这种按权重分配 CPU 只会发生在 CPU 资源紧张的情况下。如果 container_A 处于空闲状态，这时，为了充分利用 CPU 资源，container_B 也可以分配到全部可用的 CPU。</p> <p>下面我们继续用 progrium/stress 做实验。</p> <h3 id="1-启动-container_acpu-share-为-1024">1. 启动 container_A，cpu share 为 1024：</h3> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> container_A <span class="nt">-it</span> <span class="nt">-c</span> 1024 progrium/stress <span class="nt">--cpu</span> 1</code></pre></figure> <p><code class="highlighter-rouge">--cpu</code> 用来设置工作线程的数量。因为当前 host 只有 1 颗 CPU，所以一个工作线程就能将 CPU 压满。如果 host 有多颗 CPU，则需要相应增加 <code class="highlighter-rouge">--cpu</code> 的数量。</p> <h3 id="2-启动-container_bcpu-share-为-512">2. 启动 container_B，cpu share 为 512：</h3> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> container_B <span class="nt">-it</span> <span class="nt">-c</span> 512 progrium/stress <span class="nt">--cpu</span> 1</code></pre></figure> <h3 id="3-在-host-中执行-top查看容器对-cpu-的使用情况">3. 在 host 中执行 top，查看容器对 CPU 的使用情况：</h3> <p>container_A 消耗的 CPU 是 container_B 的两倍。</p> <h3 id="4-现在暂停-container_a">4. 现在暂停 container_A：</h3> <p><code class="highlighter-rouge">top</code> 显示 container_B 在 container_A 空闲的情况下能够用满整颗 CPU：</p> <h2 id="限制容器的-block-io">限制容器的 Block IO</h2> <p>Block IO 是另一种可以限制容器使用的资源。Block IO 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽，下面分别讨论。</p> <blockquote> <p>注：目前 Block IO 限额只对 direct IO（不使用文件缓存）有效。</p> </blockquote> <h3 id="block-io-权重">block IO 权重</h3> <p>默认情况下，所有容器能平等地读写磁盘，可以通过设置 <code class="highlighter-rouge">--blkio-weight</code> 参数来改变容器 block IO 的优先级。</p> <p><code class="highlighter-rouge">--blkio-weight</code> 与 <code class="highlighter-rouge">--cpu-shares</code> 类似，设置的是相对权重值，默认为 500。在下面的例子中，container_A 读写磁盘的带宽是 container_B 的两倍。</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">--name</span> container_A <span class="nt">--blkio-weight</span> 600 ubuntu   

docker run <span class="nt">-it</span> <span class="nt">--name</span> container_B <span class="nt">--blkio-weight</span> 300 ubuntu</code></pre></figure> <h3 id="限制-bps-和-iops">限制 bps 和 iops</h3> <p><code class="highlighter-rouge">bps</code> 是 byte per second，每秒读写的数据量。 <code class="highlighter-rouge">iops</code> 是 io per second，每秒 IO 的次数。</p> <p>可通过以下参数控制容器的 bps 和 iops：</p> <ul> <li><code class="highlighter-rouge">--device-read-bps</code>，限制读某个设备的 bps。</li> <li><code class="highlighter-rouge">--device-write-bps</code>，限制写某个设备的 bps。</li> <li><code class="highlighter-rouge">--device-read-iops</code>，限制读某个设备的 iops。</li> <li><code class="highlighter-rouge">--device-write-iops</code>，限制写某个设备的 iops。</li> </ul> <p>下面这个例子限制容器写 /dev/sda 的速率为 30 MB/s</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-it</span> <span class="nt">--device-write-bps</span> /dev/sda:30MB ubuntu</code></pre></figure> <p><img src="http://www.forbackup.tk/assets/img/used/docker/io_test.jpg" alt="block rate @x100" /></p> <p>通过 dd 测试在容器中写磁盘的速度。因为容器的文件系统是在 host /dev/sda 上的，在容器中写文件相当于对 host /dev/sda 进行写操作。另外，<code class="highlighter-rouge">oflag=direct</code> 指定用 direct IO 方式写文件，这样 <code class="highlighter-rouge">--device-write-bps</code> 才能生效。</p> <p>结果表明，bps 25.6 MB/s 没有超过 30 MB/s 的限速。</p> <p>作为对比测试，如果不限速，结果如下：</p> <p><img src="http://www.forbackup.tk/assets/img/used/docker/io_test_unlimit.jpg" alt="block rate @x100" /></p> <div class="col-sm-2 image pull-right"> <img class="avatar-img avata" style='border="0";border-radius: 50%' src="http://www.forbackup.tk/assets/img/author/blog.svg" alt="" height="32px" width="32px"> </div> </div> <ul class="pager"> <li><a href="/docker_col/2017/08/05/docker-learn-09.html">Docker系列 9 容器常用操作</a></li> <li><a href="/docker_col/2017/08/06/docker-learn-11.html">Docker系列 11 实现容器的底层技术</a></li> </ul> </article> </div> </div> </div> <div class="footer"> <div class="container-fluid"> <div class="row-fluid"> <div class="col-sm-4 copyright"> <span>Vicky's Blog © 2018 • All right reserved.</span> </div> <div class="col-sm-4 message"> <span>Simplicity is fashionable.</span> </div> <div class="col-sm-4 madeby"> <span>Made with&nbsp;<a href="https://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;by&nbsp;Vicky.</span> </div> <a class="pull-right top" href="#top"><i class="fa fa-caret-up" aria-hidden="true"></i></a> </div> </div> </div> </div> <!-- Vendor - Global | Applicable to every website --> <!-- #### VENDOR OFFLINE #### --> <script src="http://www.forbackup.tk/assets/vendor-off/jquery/js/jquery.min.js"></script> <script src="http://www.forbackup.tk/assets/vendor-off/bootstrap/js/bootstrap.min.js"></script> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/svg-with-js/js/fontawesome-all.min.js"></script> <script src="http://www.forbackup.tk/assets/javascripts/jekyll-spotify-plugin.min.js"></script> <!-- Specific for each pages. --> <script type="text/javascript" src="http://www.forbackup.tk/assets/javascripts/post.js"></script> <!-- Add 'ga' function from Google Analytics to certain site links in Posts --> <!-- App | Global --> <script src="http://www.forbackup.tk/assets/javascripts/global.js"></script> </body> </html>




    



<!-- Include Data Base --> <!DOCTYPE html> <html lang="en" itemscope itemtype="http://schema.org/WebPage"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Docker系列 11 实现容器的底层技术 | Vicky's Blog </title> <meta name=description content=""> <meta name="robots" content="index, follow"> <meta name=viewport content="width=device-width, initial-scale=1"> <meta http-equiv="cache-control" content="public"/> <meta http-equiv="pragma" content="public"> <meta name="keywords" content="Theme, Jekyll" /> <meta name="author" content="" /> <meta property="og:locale" content="en" /> <meta property="og:site_name" content="Vicky's Blog" /> <meta property="og:type" content="WebSite" /> <meta property="og:url" content="http://www.forbackup.tk/docker_col/2017/08/06/docker-learn-11.html" /> <meta property="og:description" content="" /> <meta property="og:title" content="Docker系列 11 实现容器的底层技术 - Vicky's Blog" /> <link rel="canonical" href="http://www.forbackup.tk/docker_col/2017/08/06/docker-learn-11.html"> <link rel="alternate" type="application/rss+xml" title="Vicky's Blog" href="http://www.forbackup.tk/feed.xml"> <script type="application/ld+json"> {"@context": "http://schema.org", "@type": "WebSite", "name": "", "headline": "Vicky's Blog", "author": {"@type": "Person", "name": {"Vicky's Blog"}}, "description": "", "url": "http://www.forbackup.tk"} </script> <script type="text/javascript"> var GLOBAL_BASEURL = "http://www.forbackup.tk"; </script> <link rel="icon" type="image/png" sizes="16x16" href="http://www.forbackup.tk/assets/img/favicon/favicon-16x16.png"> <!-- #### VENDOR OFFLINE #### --> <!-- Bootstrap 3.3.6 - Offline --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/bootstrap/css/bootstrap.min.css"> <!-- Font Awesome 5.03 - Offline --> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/web-fonts-with-css/css/fontawesome-all.min.css"></script> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/space-mono/space-mono.min.css"> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/gloria-hallelujah/gloria-hallelujah.min.css"> <!-- Style Default --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/stylesheets/main.css"> <!-- Google Analytics --> </head> <body> <div class="main" id="top"> <div class="container wrapper"> <div class="row"> <div class="col-sm-3 sidebar"> <div class="row avatar"> <a href="http://www.forbackup.tk/"> <img class="img-responsive center-block avatar-img" src="http://www.forbackup.tk/assets/img/avatar/blog.svg" height="165" width="165" alt="Vicky's Blog"> </a> </div> <div class="row header"> <h2><a href="http://www.forbackup.tk/">Vicky </a></h2> </div> <div class="row menu"> <ul> <li> <i class="fa fa-home" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/">Home</a> </li> <hr class="breakline"> <li class="li-folder-open"> <i style="font-size: ;" class="fas fa-folder-open"></i>&nbsp;<a class="unlink">Blog</a> </li> <li class="li-fa-edit"> <i style="font-size: ;" class="fas fa-edit" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/general/" >General</a> </li> <li class="li-fa-docker"> <i style="font-size: ;" class="fab fa-docker" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/docker_col/" >Docker</a> </li> <li class="li-fa-table"> <i style="font-size: ;" class="fas fa-table" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/data_analysis/" >Data Analysis</a> </li> <li class="li-fa-tags"> <i style="font-size: ;" class="fas fa-tags" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/tags/" >Tags</a> </li> <li class="li-fa-briefcase"> <i style="font-size: ;" class="fas fa-briefcase" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/projects/" >Projects</a> </li> </ul> <div class="socials"> <div class="row"> <p></p> <p></p> </div> </div> </div> </div> <div class="col-sm-9 content-main"> <!-- Include Data Base --> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <!-- Next Version <div class="readmode"> <a id="btn-readmode" class="pull-right btn btn-default btn-readmode" href="">Read Mode</a> </div> --> <div class="row title"> <h1>Docker系列 11 实现容器的底层技术</h1> </div> <div class="row meta" datetime="2017-08-06"> <time class="col-sm-6 datetime"> <i class="fa fa-calendar" aria-hidden="true"></i> <span class="text tmargin ">August 06, 2017</span> </time> </div> <div class="row tag-list"> <i class="fa fa-tags" aria-hidden="true"></i> <a href="http://www.forbackup.tk/blog/tags//linux">linux</a> <a href="http://www.forbackup.tk/blog/tags//docker">docker</a> </div> <!-- <div class="row"> <ul id="markdown-toc"> <li><a href="#cgroup" id="markdown-toc-cgroup">cgroup</a></li> <li><a href="#namespace" id="markdown-toc-namespace">namespace</a> <ul> <li><a href="#mount-namespace" id="markdown-toc-mount-namespace">Mount namespace</a></li> <li><a href="#uts-namespace" id="markdown-toc-uts-namespace">UTS namespace</a></li> <li><a href="#ipc-namespace" id="markdown-toc-ipc-namespace">IPC namespace</a></li> <li><a href="#pid-namespace" id="markdown-toc-pid-namespace">PID namespace</a></li> <li><a href="#network-namespace" id="markdown-toc-network-namespace">Network namespace</a></li> <li><a href="#user-namespace" id="markdown-toc-user-namespace">User namespace</a></li> </ul> </li> <li><a href="#小结" id="markdown-toc-小结">小结</a></li> </ul> <p><code class="highlighter-rouge">cgroup</code> 和 <code class="highlighter-rouge">namespace</code> 是最重要的两种技术。cgroup 实现资源限额， namespace 实现资源隔离。</p> <h2 id="cgroup">cgroup</h2> <p><code class="highlighter-rouge">cgroup</code> 全称 <code class="highlighter-rouge">Control Group</code>。Linux 操作系统通过 cgroup 可以设置进程使用 CPU、内存 和 IO 资源的限额。相信你已经猜到了：前面我们看到的<code class="highlighter-rouge">--cpu-shares</code>、<code class="highlighter-rouge">-m</code>、<code class="highlighter-rouge">--device-write-bps</code> 实际上就是在配置 cgroup。</p> <p>cgroup 到底长什么样子呢？我们可以在 <code class="highlighter-rouge">/sys/fs/cgroup</code> 中找到它。还是用例子来说明，启动一个容器，设置 <code class="highlighter-rouge">--cpu-shares=512</code>：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--cpu-shares</span> 512 progrium/stress <span class="nt">-c</span> 1
stress: info: <span class="o">[</span>1] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: <span class="o">[</span>1] using backoff <span class="nb">sleep </span>of 3000us
stress: dbug: <span class="o">[</span>1] <span class="nt">--</span><span class="o">&gt;</span> hogcpu worker 1 <span class="o">[</span>5] forked</code></pre></figure> <p><br /></p> <p>查看容器ID</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b305cc1b397d        progrium/stress     <span class="s2">"/usr/bin/stress -..."</span>   53 seconds ago      Up 52 seconds                           objective_keller</code></pre></figure> <p>在 <code class="highlighter-rouge">/sys/fs/cgroup/cpu/docker</code> 目录中，Linux 会为每个容器创建一个 cgroup 目录，以容器长ID 命名：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span><span class="nb">pwd</span>
/sys/fs/cgroup/cpu/docker/b305cc1b397d861bd39cf655b118b24b8d0f0125acccc825450af2be423c5d6b

<span class="nv">$ </span><span class="nb">cat </span>cpu.shares 
512</code></pre></figure> <p>目录中包含所有与 cpu 相关的 cgroup 配置，文件 cpu.shares 保存的就是 <code class="highlighter-rouge">--cpu-shares</code> 的配置，值为 512。</p> <p>同样的，/sys/fs/cgroup/memory/docker 和 /sys/fs/cgroup/blkio/docker 中保存的是内存以及 Block IO 的 cgroup 配置。</p> <h2 id="namespace">namespace</h2> <p>在每个容器中，我们都可以看到文件系统，网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使 host 上只有一块物理网卡。这种方式非常好，它使得容器更像一个独立的计算机。</p> <p>Linux 实现这种方式的技术是 namespace。namespace 管理着 host 中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace 实现了容器间资源的隔离。</p> <p>Linux 使用了六种 namespace，分别对应六种资源：<code class="highlighter-rouge">Mount</code>、<code class="highlighter-rouge">UTS</code>、<code class="highlighter-rouge">IPC</code>、<code class="highlighter-rouge">PID</code>、<code class="highlighter-rouge">Network</code> 和 <code class="highlighter-rouge">User</code>，下面我们分别讨论。</p> <h3 id="mount-namespace">Mount namespace</h3> <p>Mount namespace 让容器看上去拥有整个文件系统。</p> <p>容器有自己的 <code class="highlighter-rouge">/</code> 目录，可以执行 mount 和 umount 命令。当然我们知道这些操作只在当前容器中生效，不会影响到 host 和其他容器。</p> <h3 id="uts-namespace">UTS namespace</h3> <p>简单的说，UTS namespace 让容器有自己的 hostname。 默认情况下，容器的 hostname 是它的短ID，可以通过 <code class="highlighter-rouge">-h</code> 或 <code class="highlighter-rouge">--hostname</code> 参数设置。</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker run <span class="nt">-h</span> myhost <span class="nt">-it</span> centos
<span class="nv">$ </span><span class="nb">hostname
</span>myhost</code></pre></figure> <h3 id="ipc-namespace">IPC namespace</h3> <p>IPC namespace 让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与 host 和其他容器的 IPC 混在一起。</p> <h3 id="pid-namespace">PID namespace</h3> <p>我们前面提到过，容器在 host 中以进程的形式运行。例如当前 host 中运行了两个容器：</p> <p>通过 <code class="highlighter-rouge">ps axf</code> 可以查看容器进程：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>ps axf
   PID TTY      STAT   TIME COMMAND
   ...
  3112 ?        Ssl    1:04 /usr/bin/dockerd <span class="nt">-H</span> tcp://0.0.0.0:2376 <span class="nt">-H</span> unix:///var/run/docker.sock
  3115 ?        Ssl    0:13  <span class="se">\_</span> docker-containerd <span class="nt">-l</span> unix:///var/run/docker/libcontainerd/docker-containerd.sock <span class="nt">--metrics-interval</span><span class="o">=</span>0 <span class="nt">--start-ti</span>
  8475 ?        Sl     0:00      <span class="se">\_</span> docker-containerd-shim b305cc1b397d861bd39cf655b118b24b8d0f0125acccc825450af2be423c5d6b /var/run/docker/libc
  8489 pts/2    Ss+    0:00          <span class="se">\_</span> /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1
  8502 pts/2    R+    16:46              <span class="se">\_</span> /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1</code></pre></figure> <p>所有容器的进程都挂在 dockerd 进程下，同时也可以看到容器自己的子进程。 如果我们进入到某个容器，ps 就只能看到自己的进程了：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> b305cc1b397d bash
<span class="nv">$ </span>ps axf
   PID TTY      STAT   TIME COMMAND
     6 ?        Ss     0:00 bash
    12 ?        R+     0:00  <span class="se">\_</span> ps axf
     1 ?        Ss+    0:00 /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1
     5 ?        R+    22:28 /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1</code></pre></figure> <p>而且进程的 PID 不同于 host 中对应进程的 PID，容器中 PID=1 的进程当然也不是 host 的 init 进程。也就是说：容器拥有自己独立的一套 PID，这就是 PID namespace 提供的功能。</p> <h3 id="network-namespace">Network namespace</h3> <p>Network namespace 让容器拥有自己独立的网卡、IP、路由等资源。</p> <h3 id="user-namespace">User namespace</h3> <p>User namespace 让容器能够管理自己的用户，host 不能看到容器中创建的用户。</p> <p>在容器中创建了用户 cloud，但 host 中并不会创建相应的用户。</p> <h2 id="小结">小结</h2> <p>本章首先通过大量实验学习了容器的各种操作以及容器状态之间如何转换，然后讨论了限制容器使用 CPU、内存和 Block IO 的方法，最后学习了实现容器的底层技术：cgroup 和 namespace。</p> <p>下面是容器的常用操作命令：</p> <ul> <li><code class="highlighter-rouge">create</code> 创建容器</li> <li><code class="highlighter-rouge">run</code> 运行容器</li> <li><code class="highlighter-rouge">pause</code> 暂停容器</li> <li><code class="highlighter-rouge">unpause</code> 取消暂停继续运行容器</li> <li><code class="highlighter-rouge">stop</code> 发送 SIGTERM 停止容器</li> <li><code class="highlighter-rouge">kill</code> 发送 SIGKILL 快速停止容器</li> <li><code class="highlighter-rouge">start</code> 启动容器</li> <li><code class="highlighter-rouge">restart</code> 重启容器</li> <li><code class="highlighter-rouge">attach</code> attach 到容器启动进程的终端</li> <li><code class="highlighter-rouge">exec</code> 在容器中启动新进程，通常使用 “-it” 参数</li> <li><code class="highlighter-rouge">logs</code> 显示容器启动进程的控制台输出，用 “-f” 持续打印</li> <li><code class="highlighter-rouge">rm</code> 从磁盘中删除容器</li> </ul> 3601 </div> --> <div class="row content"> <ul id="markdown-toc"> <li><a href="#cgroup" id="markdown-toc-cgroup">cgroup</a></li> <li><a href="#namespace" id="markdown-toc-namespace">namespace</a> <ul> <li><a href="#mount-namespace" id="markdown-toc-mount-namespace">Mount namespace</a></li> <li><a href="#uts-namespace" id="markdown-toc-uts-namespace">UTS namespace</a></li> <li><a href="#ipc-namespace" id="markdown-toc-ipc-namespace">IPC namespace</a></li> <li><a href="#pid-namespace" id="markdown-toc-pid-namespace">PID namespace</a></li> <li><a href="#network-namespace" id="markdown-toc-network-namespace">Network namespace</a></li> <li><a href="#user-namespace" id="markdown-toc-user-namespace">User namespace</a></li> </ul> </li> <li><a href="#小结" id="markdown-toc-小结">小结</a></li> </ul> <p><code class="highlighter-rouge">cgroup</code> 和 <code class="highlighter-rouge">namespace</code> 是最重要的两种技术。cgroup 实现资源限额， namespace 实现资源隔离。</p> <h2 id="cgroup">cgroup</h2> <p><code class="highlighter-rouge">cgroup</code> 全称 <code class="highlighter-rouge">Control Group</code>。Linux 操作系统通过 cgroup 可以设置进程使用 CPU、内存 和 IO 资源的限额。相信你已经猜到了：前面我们看到的<code class="highlighter-rouge">--cpu-shares</code>、<code class="highlighter-rouge">-m</code>、<code class="highlighter-rouge">--device-write-bps</code> 实际上就是在配置 cgroup。</p> <p>cgroup 到底长什么样子呢？我们可以在 <code class="highlighter-rouge">/sys/fs/cgroup</code> 中找到它。还是用例子来说明，启动一个容器，设置 <code class="highlighter-rouge">--cpu-shares=512</code>：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">--cpu-shares</span> 512 progrium/stress <span class="nt">-c</span> 1
stress: info: <span class="o">[</span>1] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd
stress: dbug: <span class="o">[</span>1] using backoff <span class="nb">sleep </span>of 3000us
stress: dbug: <span class="o">[</span>1] <span class="nt">--</span><span class="o">&gt;</span> hogcpu worker 1 <span class="o">[</span>5] forked</code></pre></figure> <p><br /></p> <p>查看容器ID</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b305cc1b397d        progrium/stress     <span class="s2">"/usr/bin/stress -..."</span>   53 seconds ago      Up 52 seconds                           objective_keller</code></pre></figure> <p>在 <code class="highlighter-rouge">/sys/fs/cgroup/cpu/docker</code> 目录中，Linux 会为每个容器创建一个 cgroup 目录，以容器长ID 命名：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span><span class="nb">pwd</span>
/sys/fs/cgroup/cpu/docker/b305cc1b397d861bd39cf655b118b24b8d0f0125acccc825450af2be423c5d6b

<span class="nv">$ </span><span class="nb">cat </span>cpu.shares 
512</code></pre></figure> <p>目录中包含所有与 cpu 相关的 cgroup 配置，文件 cpu.shares 保存的就是 <code class="highlighter-rouge">--cpu-shares</code> 的配置，值为 512。</p> <p>同样的，/sys/fs/cgroup/memory/docker 和 /sys/fs/cgroup/blkio/docker 中保存的是内存以及 Block IO 的 cgroup 配置。</p> <h2 id="namespace">namespace</h2> <p>在每个容器中，我们都可以看到文件系统，网卡等资源，这些资源看上去是容器自己的。拿网卡来说，每个容器都会认为自己有一块独立的网卡，即使 host 上只有一块物理网卡。这种方式非常好，它使得容器更像一个独立的计算机。</p> <p>Linux 实现这种方式的技术是 namespace。namespace 管理着 host 中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。换句话说，namespace 实现了容器间资源的隔离。</p> <p>Linux 使用了六种 namespace，分别对应六种资源：<code class="highlighter-rouge">Mount</code>、<code class="highlighter-rouge">UTS</code>、<code class="highlighter-rouge">IPC</code>、<code class="highlighter-rouge">PID</code>、<code class="highlighter-rouge">Network</code> 和 <code class="highlighter-rouge">User</code>，下面我们分别讨论。</p> <h3 id="mount-namespace">Mount namespace</h3> <p>Mount namespace 让容器看上去拥有整个文件系统。</p> <p>容器有自己的 <code class="highlighter-rouge">/</code> 目录，可以执行 mount 和 umount 命令。当然我们知道这些操作只在当前容器中生效，不会影响到 host 和其他容器。</p> <h3 id="uts-namespace">UTS namespace</h3> <p>简单的说，UTS namespace 让容器有自己的 hostname。 默认情况下，容器的 hostname 是它的短ID，可以通过 <code class="highlighter-rouge">-h</code> 或 <code class="highlighter-rouge">--hostname</code> 参数设置。</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker run <span class="nt">-h</span> myhost <span class="nt">-it</span> centos
<span class="nv">$ </span><span class="nb">hostname
</span>myhost</code></pre></figure> <h3 id="ipc-namespace">IPC namespace</h3> <p>IPC namespace 让容器拥有自己的共享内存和信号量（semaphore）来实现进程间通信，而不会与 host 和其他容器的 IPC 混在一起。</p> <h3 id="pid-namespace">PID namespace</h3> <p>我们前面提到过，容器在 host 中以进程的形式运行。例如当前 host 中运行了两个容器：</p> <p>通过 <code class="highlighter-rouge">ps axf</code> 可以查看容器进程：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>ps axf
   PID TTY      STAT   TIME COMMAND
   ...
  3112 ?        Ssl    1:04 /usr/bin/dockerd <span class="nt">-H</span> tcp://0.0.0.0:2376 <span class="nt">-H</span> unix:///var/run/docker.sock
  3115 ?        Ssl    0:13  <span class="se">\_</span> docker-containerd <span class="nt">-l</span> unix:///var/run/docker/libcontainerd/docker-containerd.sock <span class="nt">--metrics-interval</span><span class="o">=</span>0 <span class="nt">--start-ti</span>
  8475 ?        Sl     0:00      <span class="se">\_</span> docker-containerd-shim b305cc1b397d861bd39cf655b118b24b8d0f0125acccc825450af2be423c5d6b /var/run/docker/libc
  8489 pts/2    Ss+    0:00          <span class="se">\_</span> /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1
  8502 pts/2    R+    16:46              <span class="se">\_</span> /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1</code></pre></figure> <p>所有容器的进程都挂在 dockerd 进程下，同时也可以看到容器自己的子进程。 如果我们进入到某个容器，ps 就只能看到自己的进程了：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> b305cc1b397d bash
<span class="nv">$ </span>ps axf
   PID TTY      STAT   TIME COMMAND
     6 ?        Ss     0:00 bash
    12 ?        R+     0:00  <span class="se">\_</span> ps axf
     1 ?        Ss+    0:00 /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1
     5 ?        R+    22:28 /usr/bin/stress <span class="nt">--verbose</span> <span class="nt">-c</span> 1</code></pre></figure> <p>而且进程的 PID 不同于 host 中对应进程的 PID，容器中 PID=1 的进程当然也不是 host 的 init 进程。也就是说：容器拥有自己独立的一套 PID，这就是 PID namespace 提供的功能。</p> <h3 id="network-namespace">Network namespace</h3> <p>Network namespace 让容器拥有自己独立的网卡、IP、路由等资源。</p> <h3 id="user-namespace">User namespace</h3> <p>User namespace 让容器能够管理自己的用户，host 不能看到容器中创建的用户。</p> <p>在容器中创建了用户 cloud，但 host 中并不会创建相应的用户。</p> <h2 id="小结">小结</h2> <p>本章首先通过大量实验学习了容器的各种操作以及容器状态之间如何转换，然后讨论了限制容器使用 CPU、内存和 Block IO 的方法，最后学习了实现容器的底层技术：cgroup 和 namespace。</p> <p>下面是容器的常用操作命令：</p> <ul> <li><code class="highlighter-rouge">create</code> 创建容器</li> <li><code class="highlighter-rouge">run</code> 运行容器</li> <li><code class="highlighter-rouge">pause</code> 暂停容器</li> <li><code class="highlighter-rouge">unpause</code> 取消暂停继续运行容器</li> <li><code class="highlighter-rouge">stop</code> 发送 SIGTERM 停止容器</li> <li><code class="highlighter-rouge">kill</code> 发送 SIGKILL 快速停止容器</li> <li><code class="highlighter-rouge">start</code> 启动容器</li> <li><code class="highlighter-rouge">restart</code> 重启容器</li> <li><code class="highlighter-rouge">attach</code> attach 到容器启动进程的终端</li> <li><code class="highlighter-rouge">exec</code> 在容器中启动新进程，通常使用 “-it” 参数</li> <li><code class="highlighter-rouge">logs</code> 显示容器启动进程的控制台输出，用 “-f” 持续打印</li> <li><code class="highlighter-rouge">rm</code> 从磁盘中删除容器</li> </ul> <div class="col-sm-2 image pull-right"> <img class="avatar-img avata" style='border="0";border-radius: 50%' src="http://www.forbackup.tk/assets/img/author/blog.svg" alt="" height="32px" width="32px"> </div> </div> <ul class="pager"> <li><a href="/docker_col/2017/08/06/docker-learn-10.html">Docker系列 10 限制容器对内存的使用</a></li> <li><a href="/docker_col/2017/08/06/docker-learn-12.html">Docker系列 12 容器网络</a></li> </ul> </article> </div> </div> </div> <div class="footer"> <div class="container-fluid"> <div class="row-fluid"> <div class="col-sm-4 copyright"> <span>Vicky's Blog © 2018 • All right reserved.</span> </div> <div class="col-sm-4 message"> <span>Simplicity is fashionable.</span> </div> <div class="col-sm-4 madeby"> <span>Made with&nbsp;<a href="https://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;by&nbsp;Vicky.</span> </div> <a class="pull-right top" href="#top"><i class="fa fa-caret-up" aria-hidden="true"></i></a> </div> </div> </div> </div> <!-- Vendor - Global | Applicable to every website --> <!-- #### VENDOR OFFLINE #### --> <script src="http://www.forbackup.tk/assets/vendor-off/jquery/js/jquery.min.js"></script> <script src="http://www.forbackup.tk/assets/vendor-off/bootstrap/js/bootstrap.min.js"></script> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/svg-with-js/js/fontawesome-all.min.js"></script> <script src="http://www.forbackup.tk/assets/javascripts/jekyll-spotify-plugin.min.js"></script> <!-- Specific for each pages. --> <script type="text/javascript" src="http://www.forbackup.tk/assets/javascripts/post.js"></script> <!-- Add 'ga' function from Google Analytics to certain site links in Posts --> <!-- App | Global --> <script src="http://www.forbackup.tk/assets/javascripts/global.js"></script> </body> </html>

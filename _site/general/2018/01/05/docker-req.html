


    



<!-- Include Data Base --> <!DOCTYPE html> <html lang="en" itemscope itemtype="http://schema.org/WebPage"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Docker 常用操作 | Vicky's Blog </title> <meta name=description content=""> <meta name="robots" content="index, follow"> <meta name=viewport content="width=device-width, initial-scale=1"> <meta http-equiv="cache-control" content="public"/> <meta http-equiv="pragma" content="public"> <meta name="keywords" content="Theme, Jekyll" /> <meta name="author" content="" /> <meta property="og:locale" content="en" /> <meta property="og:site_name" content="Vicky's Blog" /> <meta property="og:type" content="WebSite" /> <meta property="og:url" content="http://www.forbackup.tk/general/2018/01/05/docker-req.html" /> <meta property="og:description" content="" /> <meta property="og:title" content="Docker 常用操作 - Vicky's Blog" /> <link rel="canonical" href="http://www.forbackup.tk/general/2018/01/05/docker-req.html"> <link rel="alternate" type="application/rss+xml" title="Vicky's Blog" href="http://www.forbackup.tk/feed.xml"> <script type="application/ld+json"> {"@context": "http://schema.org", "@type": "WebSite", "name": "", "headline": "Vicky's Blog", "author": {"@type": "Person", "name": {"Vicky's Blog"}}, "description": "", "url": "http://www.forbackup.tk"} </script> <script type="text/javascript"> var GLOBAL_BASEURL = "http://www.forbackup.tk"; </script> <link rel="icon" type="image/png" sizes="16x16" href="http://www.forbackup.tk/assets/img/favicon/favicon-16x16.png"> <!-- #### VENDOR OFFLINE #### --> <!-- Bootstrap 3.3.6 - Offline --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/bootstrap/css/bootstrap.min.css"> <!-- Font Awesome 5.03 - Offline --> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/web-fonts-with-css/css/fontawesome-all.min.css"></script> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/space-mono/space-mono.min.css"> <link rel="stylesheet" href="http://www.forbackup.tk/assets/vendor-off/fonts/gloria-hallelujah/gloria-hallelujah.min.css"> <!-- Style Default --> <link rel="stylesheet" href="http://www.forbackup.tk/assets/stylesheets/main.css"> <!-- Google Analytics --> </head> <body> <div class="main" id="top"> <div class="container wrapper"> <div class="row"> <div class="col-sm-3 sidebar"> <div class="row avatar"> <a href="http://www.forbackup.tk/"> <img class="img-responsive center-block avatar-img" src="http://www.forbackup.tk/assets/img/avatar/blog.svg" height="165" width="165" alt="Vicky's Blog"> </a> </div> <div class="row header"> <h2><a href="http://www.forbackup.tk/">Vicky </a></h2> </div> <div class="row menu"> <ul> <li> <i class="fa fa-home" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/">Home</a> </li> <hr class="breakline"> <li class="li-folder-open"> <i style="font-size: ;" class="fas fa-folder-open"></i>&nbsp;<a class="unlink">Blog</a> </li> <li class="li-fa-edit"> <i style="font-size: ;" class="fas fa-edit" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/general/" >General</a> </li> <li class="li-fa-docker"> <i style="font-size: ;" class="fab fa-docker" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/docker_col/" >Docker</a> </li> <li class="li-fa-table"> <i style="font-size: ;" class="fas fa-table" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/data_analysis/" >Data Analysis</a> </li> <li class="li-fa-tags"> <i style="font-size: ;" class="fas fa-tags" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/tags/" >Tags</a> </li> <li class="li-fa-briefcase"> <i style="font-size: ;" class="fas fa-briefcase" aria-hidden="true"></i>&nbsp;<a href="http://www.forbackup.tk/blog/projects/" >Projects</a> </li> </ul> <div class="socials"> <div class="row"> <p></p> <p></p> </div> </div> </div> </div> <div class="col-sm-9 content-main"> <!-- Include Data Base --> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <!-- Next Version <div class="readmode"> <a id="btn-readmode" class="pull-right btn btn-default btn-readmode" href="">Read Mode</a> </div> --> <div class="row title"> <h1>Docker 常用操作</h1> </div> <div class="row meta" datetime="2018-01-05"> <time class="col-sm-6 datetime"> <i class="fa fa-calendar" aria-hidden="true"></i> <span class="text tmargin ">January 05, 2018</span> </time> </div> <div class="row tag-list"> <i class="fa fa-tags" aria-hidden="true"></i> <a href="http://www.forbackup.tk/blog/tags//常用操作">常用操作</a> <a href="http://www.forbackup.tk/blog/tags//linux">linux</a> <a href="http://www.forbackup.tk/blog/tags//docker">docker</a> </div> <!-- <div class="row"> <ul id="markdown-toc"> <li><a href="#运行" id="markdown-toc-运行">运行</a></li> <li><a href="#管理容器" id="markdown-toc-管理容器">管理容器</a></li> <li><a href="#管理镜像" id="markdown-toc-管理镜像">管理镜像</a></li> <li><a href="#dockerfile" id="markdown-toc-dockerfile">Dockerfile</a></li> <li><a href="#docker-compose" id="markdown-toc-docker-compose">docker-compose</a></li> <li><a href="#tips" id="markdown-toc-tips">Tips</a></li> <li><a href="#进入退出-docker容器" id="markdown-toc-进入退出-docker容器">进入退出 Docker容器</a></li> <li><a href="#add-user-to-docker-group" id="markdown-toc-add-user-to-docker-group">add user to docker group</a></li> <li><a href="#代理设置" id="markdown-toc-代理设置">代理设置</a></li> <li><a href="#相关资源" id="markdown-toc-相关资源">相关资源</a></li> </ul> <h2 id="运行">运行</h2> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run
  <span class="nt">--name</span> 指定容器名
  <span class="nt">-p</span> 指定端口映射
  <span class="nt">-v</span> 挂载数据卷或者本地目录映射 :ro 挂载为只读
  <span class="nt">-d</span> 后台持续运行
  <span class="nt">-i</span> 交互式操作
  <span class="nt">-t</span> 终端
  <span class="nt">-rm</span> 容器退出后随之将其删除<span class="o">(</span>与-d 冲突<span class="o">)</span></code></pre></figure> <p>eg:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> localregistry <span class="nt">-d</span> <span class="nt">-v</span> /disk2/dockrepo:/var/lib/registry <span class="nt">-p</span> 5000:5000 registry
docker run <span class="nt">-it</span> <span class="nt">--rm</span> ubuntu:14.04 bash
<span class="nb">sudo </span>docker run ubuntu:14.04 /bin/echo <span class="s1">'Hello world'</span>
docker run <span class="nt">--name</span> webserver <span class="nt">-d</span> <span class="nt">-p</span> 80:80 nginx</code></pre></figure> <h2 id="管理容器">管理容器</h2> <ul> <li><code class="highlighter-rouge">docker ps</code> 列出正在运行的容器</li> <li><code class="highlighter-rouge">docker kill $(docker ps -q)</code> 停止所有正在运行的容器</li> <li><code class="highlighter-rouge">docker ps -a</code> 查看停止状态的容器</li> <li><code class="highlighter-rouge">docker start</code> 启动一个已有容器</li> <li><code class="highlighter-rouge">docker stop</code> 终止一个运行中的容器</li> <li><code class="highlighter-rouge">docker restart</code> 重启某个容器</li> <li><code class="highlighter-rouge">docker rm xxxx</code> 删除容器 <code class="highlighter-rouge">-f</code> 删除运行中的</li> <li><code class="highlighter-rouge">docker rm $(docker ps -a -q)</code> 删除所有终止的容器</li> <li><code class="highlighter-rouge">docker logs [container id or names]</code> 获取输出log</li> <li><code class="highlighter-rouge">docker diff</code> 容器名 查看我们定制以及修改</li> <li><code class="highlighter-rouge">docker volume ls</code> 列出所有本机的数据卷</li> </ul> <h2 id="管理镜像">管理镜像</h2> <ul> <li><code class="highlighter-rouge">docker pull [option] [url]</code> 获取镜像 <ul> <li>eg: <code class="highlighter-rouge">docker pull ubuntu:14.04</code></li> </ul> </li> <li><code class="highlighter-rouge">docker images</code> 列出本地镜像</li> <li><code class="highlighter-rouge">docker build -t nginx:v3 .</code> 在当前目录构建镜像,-t 是指定 <strong>镜像名称 tag</strong></li> <li><code class="highlighter-rouge">docker rmi xxxxxx</code> 删除本地镜像</li> <li><code class="highlighter-rouge">docker commit 选项 容器名/id 仓库名 tag</code> 可以把修改定制过的容器保存为镜像</li> <li><code class="highlighter-rouge">docker images -f dangling=true</code> 列出所有虚悬镜像(dangling image)</li> <li><code class="highlighter-rouge">docker rmi $(docker images -q -f dangling=true)</code> 删除所有虚悬镜像</li> <li><code class="highlighter-rouge">docker histroy 镜像名:标签</code> 查看镜像修改的历史纪录</li> </ul> <h2 id="dockerfile">Dockerfile</h2> <ul> <li>COPY 原路径 目标路径</li> <li>ADD 性质基本与COPY类似，但支持自动解压</li> <li>VOLUME 可以定义匿名卷，执行时可被覆盖</li> <li>EXPOSE 声明端口</li> <li>WORKDIR 指定工作目录</li> <li>USER 指定当前用户</li> <li>HEALTHCHECK 健康检查</li> <li>ONBUILD 被作为基础镜像时才执行</li> </ul> <h2 id="docker-compose">docker-compose</h2> <ul> <li><code class="highlighter-rouge">-p</code> 指定项目名称</li> <li><code class="highlighter-rouge">build</code> 构建项目中的服务容器</li> <li><code class="highlighter-rouge">--force-rm</code> 删除构建过程中的临时容器</li> <li><code class="highlighter-rouge">--no-cache</code> 构建过程中不使用 cache</li> <li><code class="highlighter-rouge">--pull</code> 始终通过 <code class="highlighter-rouge">pull</code> 来获取更新版本的镜像</li> <li><code class="highlighter-rouge">docker-compose kill</code> 强制停止服务容器</li> <li><code class="highlighter-rouge">docker-compose logs</code> 查看容器的输出 调试必备</li> <li><code class="highlighter-rouge">docker-compose pause</code> 暂停一个服务容器</li> <li><code class="highlighter-rouge">docker-compose unpause</code> 恢复暂停</li> <li><code class="highlighter-rouge">docker-compose port</code> 打印某个容器端口所映射的公共端口</li> <li><code class="highlighter-rouge">docker-compose ps</code> 列出项目中目前的所有容器 -q 只打印容器 id</li> <li><code class="highlighter-rouge">docker-compose pull</code> 拉取服务依赖的镜像</li> <li><code class="highlighter-rouge">docker-compose restart -t</code> 指定重启前停止容器的超时默认10秒</li> <li><code class="highlighter-rouge">docker-compose rm</code> 删除所有停止状态的容器先执行 stop</li> <li><code class="highlighter-rouge">docker-compose run</code> 指定服务上执行一个命令</li> <li><code class="highlighter-rouge">docker-compose start</code> 启动已经存在的服务容器</li> <li><code class="highlighter-rouge">docker-compose stop</code></li> <li><code class="highlighter-rouge">docker-compose up</code> 自动构建、创建服务、启动服务，关联一系列，运行在前台，<code class="highlighter-rouge">ctrl c</code> 就都停止运行。如果容器已经存在，将会尝试停止容器，重新创建。</li> <li><code class="highlighter-rouge">--no-recreate</code> 不希望重新创建,就只启动处于停止状态的容器，</li> <li><code class="highlighter-rouge">docker-compose up --no-deps -d</code> 只想重新部署某个服务，不影响其所依赖的服务</li> <li><code class="highlighter-rouge">docker-compose up -d</code> 后台启动运行，生产环境必备</li> </ul> <h2 id="tips">Tips</h2> <p>容器在运行时，以镜像为基础层，在其上创建一个当前容器的存储层，使用 go 语言开发的应用更多的会使用 <code class="highlighter-rouge">FROM scratch</code> 来做空白镜像为基础</p> <p>Dockerfile 中，RUN 执行命令，直接写需要在bash中执行的命令。如果每条命令都作为一个 RUN 单独存在，就相当于每个指令都建立一层，很多不需要的东西都被装进了镜像里，比如编译环境，更新的软件包等等，最终会产生出非常臃肿，非常多层的镜像，增加了构建部署的时间。也很容易出错。正确的写法是把每一大块，或者说每一个软件环境的相关命令集成在一个 RUN 里。</p> <h2 id="进入退出-docker容器">进入退出 Docker容器</h2> <p>启动了Docker容器，比如</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-itd</span> <span class="nt">-p</span> 3000:3000 <span class="nt">--name</span> my-web <span class="nt">-v</span> <span class="s2">"</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">"</span>:/webapp <span class="nt">-w</span> /webapp node npm start</code></pre></figure> <p>如何看到终端打印的报错和日志呢？</p> <p>docker有命令可以让你进入（attach）和退出（detach）该进程。</p> <p>进入：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker attach my-web</code></pre></figure> <p>退出，一定不要用ctrl+c，那样就是让docker容器停止了。</p> <p>要用如下快捷键：</p> <ul> <li>先按，ctrl+p</li> <li>再按，ctrl+q</li> </ul> <h2 id="add-user-to-docker-group">add user to docker group</h2> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">sudo </span>groupadd docker

<span class="nb">sudo </span>gpasswd <span class="nt">-a</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span> docker</code></pre></figure> <h2 id="代理设置">代理设置</h2> <p>该方法是持久化的，修改后会一直生效。该方法覆盖了默认的docker.service文件。</p> <ol> <li>为docker服务创建一个内嵌的systemd目录 <code class="highlighter-rouge">mkdir -p /etc/systemd/system/docker.service.d</code></li> <li>创建<code class="highlighter-rouge">/etc/systemd/system/docker.service.d/http-proxy.conf</code>文件，并添加<code class="highlighter-rouge">HTTP_PROXY</code>环境变量。其中<code class="highlighter-rouge">[proxy-addr]</code>和<code class="highlighter-rouge">[proxy-port]</code>分别改成实际情况的代理地址和端口： <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [Service]
 Environment="HTTP_PROXY=http://[proxy-addr]:[proxy-port]/" "HTTPS_PROXY=https://[proxy-addr]:[proxy-port]/"
</code></pre></div> </div> </li> <li>如果还有内部的不需要使用代理来访问的Docker registries，那么需要制定<code class="highlighter-rouge">NO_PROXY</code>环境变量： <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [Service]
 Environment="HTTP_PROXY=http://[proxy-addr]:[proxy-port]/" "HTTPS_PROXY=https://[proxy-addr]:[proxy-port]/" "NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com"
</code></pre></div> </div> </li> <li>更新配置： <code class="highlighter-rouge">systemctl daemon-reload</code></li> <li>重启Docker服务： <code class="highlighter-rouge">systemctl restart docker</code></li> </ol> <h2 id="相关资源">相关资源</h2> <ul> <li><a href="https://docs.docker.com/engine/admin/systemd/#http-proxy*">Control and configure Docker with systemd</a></li> <li><a href="https://docs.docker.com/v1.11/engine/reference/commandline/daemon/#daemon-socket-option">Daemon socket option</a></li> </ul> 3416 </div> --> <div class="row content"> <ul id="markdown-toc"> <li><a href="#运行" id="markdown-toc-运行">运行</a></li> <li><a href="#管理容器" id="markdown-toc-管理容器">管理容器</a></li> <li><a href="#管理镜像" id="markdown-toc-管理镜像">管理镜像</a></li> <li><a href="#dockerfile" id="markdown-toc-dockerfile">Dockerfile</a></li> <li><a href="#docker-compose" id="markdown-toc-docker-compose">docker-compose</a></li> <li><a href="#tips" id="markdown-toc-tips">Tips</a></li> <li><a href="#进入退出-docker容器" id="markdown-toc-进入退出-docker容器">进入退出 Docker容器</a></li> <li><a href="#add-user-to-docker-group" id="markdown-toc-add-user-to-docker-group">add user to docker group</a></li> <li><a href="#代理设置" id="markdown-toc-代理设置">代理设置</a></li> <li><a href="#相关资源" id="markdown-toc-相关资源">相关资源</a></li> </ul> <h2 id="运行">运行</h2> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run
  <span class="nt">--name</span> 指定容器名
  <span class="nt">-p</span> 指定端口映射
  <span class="nt">-v</span> 挂载数据卷或者本地目录映射 :ro 挂载为只读
  <span class="nt">-d</span> 后台持续运行
  <span class="nt">-i</span> 交互式操作
  <span class="nt">-t</span> 终端
  <span class="nt">-rm</span> 容器退出后随之将其删除<span class="o">(</span>与-d 冲突<span class="o">)</span></code></pre></figure> <p>eg:</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">--name</span> localregistry <span class="nt">-d</span> <span class="nt">-v</span> /disk2/dockrepo:/var/lib/registry <span class="nt">-p</span> 5000:5000 registry
docker run <span class="nt">-it</span> <span class="nt">--rm</span> ubuntu:14.04 bash
<span class="nb">sudo </span>docker run ubuntu:14.04 /bin/echo <span class="s1">'Hello world'</span>
docker run <span class="nt">--name</span> webserver <span class="nt">-d</span> <span class="nt">-p</span> 80:80 nginx</code></pre></figure> <h2 id="管理容器">管理容器</h2> <ul> <li><code class="highlighter-rouge">docker ps</code> 列出正在运行的容器</li> <li><code class="highlighter-rouge">docker kill $(docker ps -q)</code> 停止所有正在运行的容器</li> <li><code class="highlighter-rouge">docker ps -a</code> 查看停止状态的容器</li> <li><code class="highlighter-rouge">docker start</code> 启动一个已有容器</li> <li><code class="highlighter-rouge">docker stop</code> 终止一个运行中的容器</li> <li><code class="highlighter-rouge">docker restart</code> 重启某个容器</li> <li><code class="highlighter-rouge">docker rm xxxx</code> 删除容器 <code class="highlighter-rouge">-f</code> 删除运行中的</li> <li><code class="highlighter-rouge">docker rm $(docker ps -a -q)</code> 删除所有终止的容器</li> <li><code class="highlighter-rouge">docker logs [container id or names]</code> 获取输出log</li> <li><code class="highlighter-rouge">docker diff</code> 容器名 查看我们定制以及修改</li> <li><code class="highlighter-rouge">docker volume ls</code> 列出所有本机的数据卷</li> </ul> <h2 id="管理镜像">管理镜像</h2> <ul> <li><code class="highlighter-rouge">docker pull [option] [url]</code> 获取镜像 <ul> <li>eg: <code class="highlighter-rouge">docker pull ubuntu:14.04</code></li> </ul> </li> <li><code class="highlighter-rouge">docker images</code> 列出本地镜像</li> <li><code class="highlighter-rouge">docker build -t nginx:v3 .</code> 在当前目录构建镜像,-t 是指定 <strong>镜像名称 tag</strong></li> <li><code class="highlighter-rouge">docker rmi xxxxxx</code> 删除本地镜像</li> <li><code class="highlighter-rouge">docker commit 选项 容器名/id 仓库名 tag</code> 可以把修改定制过的容器保存为镜像</li> <li><code class="highlighter-rouge">docker images -f dangling=true</code> 列出所有虚悬镜像(dangling image)</li> <li><code class="highlighter-rouge">docker rmi $(docker images -q -f dangling=true)</code> 删除所有虚悬镜像</li> <li><code class="highlighter-rouge">docker histroy 镜像名:标签</code> 查看镜像修改的历史纪录</li> </ul> <h2 id="dockerfile">Dockerfile</h2> <ul> <li>COPY 原路径 目标路径</li> <li>ADD 性质基本与COPY类似，但支持自动解压</li> <li>VOLUME 可以定义匿名卷，执行时可被覆盖</li> <li>EXPOSE 声明端口</li> <li>WORKDIR 指定工作目录</li> <li>USER 指定当前用户</li> <li>HEALTHCHECK 健康检查</li> <li>ONBUILD 被作为基础镜像时才执行</li> </ul> <h2 id="docker-compose">docker-compose</h2> <ul> <li><code class="highlighter-rouge">-p</code> 指定项目名称</li> <li><code class="highlighter-rouge">build</code> 构建项目中的服务容器</li> <li><code class="highlighter-rouge">--force-rm</code> 删除构建过程中的临时容器</li> <li><code class="highlighter-rouge">--no-cache</code> 构建过程中不使用 cache</li> <li><code class="highlighter-rouge">--pull</code> 始终通过 <code class="highlighter-rouge">pull</code> 来获取更新版本的镜像</li> <li><code class="highlighter-rouge">docker-compose kill</code> 强制停止服务容器</li> <li><code class="highlighter-rouge">docker-compose logs</code> 查看容器的输出 调试必备</li> <li><code class="highlighter-rouge">docker-compose pause</code> 暂停一个服务容器</li> <li><code class="highlighter-rouge">docker-compose unpause</code> 恢复暂停</li> <li><code class="highlighter-rouge">docker-compose port</code> 打印某个容器端口所映射的公共端口</li> <li><code class="highlighter-rouge">docker-compose ps</code> 列出项目中目前的所有容器 -q 只打印容器 id</li> <li><code class="highlighter-rouge">docker-compose pull</code> 拉取服务依赖的镜像</li> <li><code class="highlighter-rouge">docker-compose restart -t</code> 指定重启前停止容器的超时默认10秒</li> <li><code class="highlighter-rouge">docker-compose rm</code> 删除所有停止状态的容器先执行 stop</li> <li><code class="highlighter-rouge">docker-compose run</code> 指定服务上执行一个命令</li> <li><code class="highlighter-rouge">docker-compose start</code> 启动已经存在的服务容器</li> <li><code class="highlighter-rouge">docker-compose stop</code></li> <li><code class="highlighter-rouge">docker-compose up</code> 自动构建、创建服务、启动服务，关联一系列，运行在前台，<code class="highlighter-rouge">ctrl c</code> 就都停止运行。如果容器已经存在，将会尝试停止容器，重新创建。</li> <li><code class="highlighter-rouge">--no-recreate</code> 不希望重新创建,就只启动处于停止状态的容器，</li> <li><code class="highlighter-rouge">docker-compose up --no-deps -d</code> 只想重新部署某个服务，不影响其所依赖的服务</li> <li><code class="highlighter-rouge">docker-compose up -d</code> 后台启动运行，生产环境必备</li> </ul> <h2 id="tips">Tips</h2> <p>容器在运行时，以镜像为基础层，在其上创建一个当前容器的存储层，使用 go 语言开发的应用更多的会使用 <code class="highlighter-rouge">FROM scratch</code> 来做空白镜像为基础</p> <p>Dockerfile 中，RUN 执行命令，直接写需要在bash中执行的命令。如果每条命令都作为一个 RUN 单独存在，就相当于每个指令都建立一层，很多不需要的东西都被装进了镜像里，比如编译环境，更新的软件包等等，最终会产生出非常臃肿，非常多层的镜像，增加了构建部署的时间。也很容易出错。正确的写法是把每一大块，或者说每一个软件环境的相关命令集成在一个 RUN 里。</p> <h2 id="进入退出-docker容器">进入退出 Docker容器</h2> <p>启动了Docker容器，比如</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run <span class="nt">-itd</span> <span class="nt">-p</span> 3000:3000 <span class="nt">--name</span> my-web <span class="nt">-v</span> <span class="s2">"</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">"</span>:/webapp <span class="nt">-w</span> /webapp node npm start</code></pre></figure> <p>如何看到终端打印的报错和日志呢？</p> <p>docker有命令可以让你进入（attach）和退出（detach）该进程。</p> <p>进入：</p> <figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker attach my-web</code></pre></figure> <p>退出，一定不要用ctrl+c，那样就是让docker容器停止了。</p> <p>要用如下快捷键：</p> <ul> <li>先按，ctrl+p</li> <li>再按，ctrl+q</li> </ul> <h2 id="add-user-to-docker-group">add user to docker group</h2> <figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nb">sudo </span>groupadd docker

<span class="nb">sudo </span>gpasswd <span class="nt">-a</span> <span class="k">${</span><span class="nv">USER</span><span class="k">}</span> docker</code></pre></figure> <h2 id="代理设置">代理设置</h2> <p>该方法是持久化的，修改后会一直生效。该方法覆盖了默认的docker.service文件。</p> <ol> <li>为docker服务创建一个内嵌的systemd目录 <code class="highlighter-rouge">mkdir -p /etc/systemd/system/docker.service.d</code></li> <li>创建<code class="highlighter-rouge">/etc/systemd/system/docker.service.d/http-proxy.conf</code>文件，并添加<code class="highlighter-rouge">HTTP_PROXY</code>环境变量。其中<code class="highlighter-rouge">[proxy-addr]</code>和<code class="highlighter-rouge">[proxy-port]</code>分别改成实际情况的代理地址和端口： <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [Service]
 Environment="HTTP_PROXY=http://[proxy-addr]:[proxy-port]/" "HTTPS_PROXY=https://[proxy-addr]:[proxy-port]/"
</code></pre></div> </div> </li> <li>如果还有内部的不需要使用代理来访问的Docker registries，那么需要制定<code class="highlighter-rouge">NO_PROXY</code>环境变量： <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> [Service]
 Environment="HTTP_PROXY=http://[proxy-addr]:[proxy-port]/" "HTTPS_PROXY=https://[proxy-addr]:[proxy-port]/" "NO_PROXY=localhost,127.0.0.1,docker-registry.somecorporation.com"
</code></pre></div> </div> </li> <li>更新配置： <code class="highlighter-rouge">systemctl daemon-reload</code></li> <li>重启Docker服务： <code class="highlighter-rouge">systemctl restart docker</code></li> </ol> <h2 id="相关资源">相关资源</h2> <ul> <li><a href="https://docs.docker.com/engine/admin/systemd/#http-proxy*">Control and configure Docker with systemd</a></li> <li><a href="https://docs.docker.com/v1.11/engine/reference/commandline/daemon/#daemon-socket-option">Daemon socket option</a></li> </ul> <div class="col-sm-2 image pull-right"> <img class="avatar-img avata" style='border="0";border-radius: 50%' src="http://www.forbackup.tk/assets/img/author/blog.svg" alt="" height="32px" width="32px"> </div> </div> <ul class="pager"> <li><a href="/general/2018/01/02/centos-fdisk.html">centos7分区 格式化挂载磁盘</a></li> <li><a href="/general/2018/01/09/frontend.html">前端资料索引</a></li> </ul> </article> </div> </div> </div> <div class="footer"> <div class="container-fluid"> <div class="row-fluid"> <div class="col-sm-4 copyright"> <span>Vicky's Blog © 2018 • All right reserved.</span> </div> <div class="col-sm-4 message"> <span>Simplicity is fashionable.</span> </div> <div class="col-sm-4 madeby"> <span>Made with&nbsp;<a href="https://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;by&nbsp;Vicky.</span> </div> <a class="pull-right top" href="#top"><i class="fa fa-caret-up" aria-hidden="true"></i></a> </div> </div> </div> </div> <!-- Vendor - Global | Applicable to every website --> <!-- #### VENDOR OFFLINE #### --> <script src="http://www.forbackup.tk/assets/vendor-off/jquery/js/jquery.min.js"></script> <script src="http://www.forbackup.tk/assets/vendor-off/bootstrap/js/bootstrap.min.js"></script> <script defer src="http://www.forbackup.tk/assets/vendor-off/font-awesome/svg-with-js/js/fontawesome-all.min.js"></script> <script src="http://www.forbackup.tk/assets/javascripts/jekyll-spotify-plugin.min.js"></script> <!-- Specific for each pages. --> <script type="text/javascript" src="http://www.forbackup.tk/assets/javascripts/post.js"></script> <!-- Add 'ga' function from Google Analytics to certain site links in Posts --> <!-- App | Global --> <script src="http://www.forbackup.tk/assets/javascripts/global.js"></script> </body> </html>
